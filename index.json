
[{"content":"生日：2003.11.13\n现就读于西安电子科技大学网安实验班大三\n这个博客的目的是记录我的学习历程\n","date":"2024/5/18","externalUrl":null,"permalink":"/about/","section":"Enly","summary":"生日：2003.11.13","title":"About","type":"page"},{"content":"","date":"2024/5/18","externalUrl":null,"permalink":"/","section":"Enly","summary":"","title":"Enly","type":"page"},{"content":"","date":"2023/11/13","externalUrl":null,"permalink":"/blogs/","section":"Blogs","summary":"","title":"Blogs","type":"blogs"},{"content":"","date":"2023/11/13","externalUrl":null,"permalink":"/tags/miniconda/","section":"Tags","summary":"","title":"Miniconda","type":"tags"},{"content":"Miniconda安装及卸载教程\n1 快速命令行安装 # 打开 Miniconda版本仓库，查看你要安装的Miniconda版本。\n不要点击链接下载，只用查看你要安装版本的名字即可\nWindows # 打开命令行执行下面的命令：\ncurl https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe -o miniconda.exe start /wait \u0026#34;\u0026#34; miniconda.exe /S del miniconda.exe 如果你不想安装最新版本，将上面第一行命令中的Miniconda3-latest-Windows-x86_64.exe替换成你想安装版本的名字\n安装后，打开“Anaconda Prompt (miniconda3)”程序以使用Miniconda3。对于Powershell版本，请使用“Anaconda Powershell Prompt (miniconda3)”。\nmacOS # 打开命令行执行下面的命令：\nmkdir -p ~/miniconda3 curl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh -o ~/miniconda3/miniconda.sh bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3 rm -rf ~/miniconda3/miniconda.sh 上面第二行命令适用于苹果M芯片的最新Miniconda版本，如果你要安装Intel芯片，或者不想安装最新版本，请将第二行命令中的Miniconda3-latest-MacOSX-arm64.sh替换成你想安装版本的名字\n安装后，初始化新安装的Miniconda。以下命令为bash和zsh shell初始化：\n~/miniconda3/bin/conda init bash ~/miniconda3/bin/conda init zsh Linux # 打开命令行执行下面的命令：\nmkdir -p ~/miniconda3 wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3 rm -rf ~/miniconda3/miniconda.sh 如果不想安装最新版本，请将第二行命令中的Miniconda3-latest-Linux-x86_64.sh替换成你想安装版本的名字\n安装后，初始化新安装的Miniconda。以下命令为bash和zsh shell初始化：\n~/miniconda3/bin/conda init bash ~/miniconda3/bin/conda init zsh 2 conda配置国内镜像源 # 推荐配置中科大镜像源，其他镜像源可以自行搜索配置。\n打开命令行执行以下命令：\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ #设置搜索时显示通道地址 conda config --set show_channel_urls yes 显示现有安装源：\nconda config --show channels 恢复默认源：\nconda config --remove-key channels 移除某个源：\nconda config --remove channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ 3 conda常用命令 # 功能 命令 获取版本号 conda -v 获取帮助 conda -h 创建环境 conda create -n environment_name 创建指定python版本下包含某些包的环境 conda create -n environment_name python= 3.7 numpy scipy 进入环境 conda activate environment_name 退出环境 conda deactivate 删除环境 conda remove -n environment_name - -all 列出所有环境 conda env list 将旧环境复制到新环境 conda create - -name new_env_name - -clone old_env_name 安装包 conda instal package_name 查看当前环境包列表 conda list 查看指定环境包列表 conda list -n environment_name 查看conda源中包的信息 conda search package_name 更新包 conda update package_name 删除包 conda remove package_name 清理无用的安装包 conda clean -p 清理tar包 conda clean -t 清理所有安装包及cache conda clean -y - -all 4 Miniconda卸载 # 以下为Mac卸载，Windows卸载请自行搜索\n(1) 使用Anaconda-Clean包删除所有与conda相关的文件和目录：\nconda activate environment_name conda install anaconda-clean anaconda-clean # add `--yes` to avoid being prompted to delete each one (2) 删除整个目录（直接删掉安装文件就可）\nrm -rf ~/miniconda3 (3) 删除PATH环境变量中的conda路径\nvim ~/.bashrc # 将下图所示的# \u0026gt;\u0026gt;\u0026gt; conda initialize \u0026gt;\u0026gt;\u0026gt;和# \u0026lt;\u0026lt;\u0026lt; conda initialize \u0026lt;\u0026lt;\u0026lt;之间的所有内容删除 # 删除完保存退出后执行下面的命令 source ~/.bashrc 同理，对zsh也执行上述操作。\nvim ~/.bashrc # 将下图所示的# \u0026gt;\u0026gt;\u0026gt; conda initialize \u0026gt;\u0026gt;\u0026gt;和# \u0026lt;\u0026lt;\u0026lt; conda initialize \u0026lt;\u0026lt;\u0026lt;之间的所有内容删除 # 删除完保存退出后执行下面的命令 source ~/.bashrc (4) 删除配置文件\nrm -rf ~/.condarc ","date":"2023/11/13","externalUrl":null,"permalink":"/blogs/condainstall/","section":"Blogs","summary":"Miniconda安装及卸载教程","title":"Miniconda安装及卸载教程","type":"blogs"},{"content":"","date":"2023/11/13","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2023/7/22","externalUrl":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"机器学习","type":"tags"},{"content":"","date":"2023/7/22","externalUrl":null,"permalink":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"深度学习","type":"tags"},{"content":"花书 - 《 深度学习 》学习笔记\n","date":"2023/7/22","externalUrl":null,"permalink":"/blogs/flowernote/","section":"Blogs","summary":"花书 - 《 深度学习 》学习笔记","title":"花书笔记","type":"blogs"},{"content":"西瓜书 - 《 机器学习 》学习笔记 - 9-16章\n第9章 聚类 # 第10章 降维与度量学习 # 第11章 特征选择与稀疏学习 # 第12章 计算学习理论 # 第13章 半监督学习 # 第14章 概率图模型 # 第15章规则学习 # 第16章 强化学习 # ","date":"2023/4/23","externalUrl":null,"permalink":"/blogs/watermelonnote2/","section":"Blogs","summary":"西瓜书 - 《 机器学习 》学习笔记 - 9-16章","title":"西瓜书笔记(下)","type":"blogs"},{"content":"西瓜书 - 《 机器学习 》 学习笔记 - 1-8章\n第1章 绪论 # 第2章 模型评估与选择 # 第3章 线性模型 # 第4章 决策树 # 第5章 神经网络 # 第6章 支持向量机 # 第7章 贝叶斯分类 # 第8章 集成学习 # ","date":"2023/4/12","externalUrl":null,"permalink":"/blogs/watermelonnote1/","section":"Blogs","summary":"西瓜书 - 《 机器学习 》 学习笔记 - 1-8章","title":"西瓜书笔记(上)","type":"blogs"},{"content":"","date":"2022/11/22","externalUrl":null,"permalink":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"Tags","summary":"","title":"编译原理","type":"tags"},{"content":"西电编译原理大作业 - 函数绘图语言编译器C++实现 - 报告及代码下载链接\n链接：\nCSDN: https://download.csdn.net/download/dearliyiyang/87670357?spm=1001.2014.3001.5501\nGithub: https://github.com/ZhanYirui/FGLCompiler\n","date":"2022/11/22","externalUrl":null,"permalink":"/blogs/fglcompilerlink/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器C++实现 - 报告及代码下载链接","title":"编译原理上机 - 函数绘图语言编译器 - 报告及代码下载链接","type":"blogs"},{"content":"西电编译原理大作业 - 函数绘图语言编译器C++实现 - Part 3 - 绘图器\nauthor:En1y\ntime:2022-11-20\nschool:Xidian university\n第三部分:绘图器 (完整代码在最后)\n测试文本:\nOrigin Is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 ​ 绘图器的代码是在第二部分语法分析器的基础上改编来的。\n首先我们把第二部分语法分析器Parsers类里面的Parser()、Program()\u0026hellip;、ForStatement()成员函数里面的\u0026quot;enter in\u0026quot;、\u0026ldquo;exit from\u0026quot;以及\u0026quot;matchtoken\u0026quot;语句删除。\n在Parsers类的OriginStatement()、ScaleStatement()、RotStatement()、ForStatement()函数里面，我们得到了很多棵表达式树，在语法分析器里面我们是将它们用OutExprNode()函数先序遍历打印出来的，但是在绘图器里面，我们不需要把表达式树打印出来，我们需要表达式树它最终求出来的值，所以我们要把OutExprNode()函数改成GetExpValue()函数，两个函数很相似都是利用递归，我在语法分析器里已经分析过了，下面直接给出GetExpValue()函数的代码:\ndouble GetExpValue(struct ExprNode* Tree) { if (Tree == NULL) return 0.0; switch (Tree-\u0026gt;OpCode) { case PLUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) + GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MINUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) - GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MUL: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) * GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case DIV: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) / GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case POWER: return pow(GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left), GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right)); case FUNC: return Tree-\u0026gt;Content.CaseFunc.MathFuncPtr(GetExpValue(Tree-\u0026gt;Content.CaseFunc.Child)); case CONST_ID: return Tree-\u0026gt;Content.CaseConst; case T: return *(Tree-\u0026gt;Content.CaseParmPtr); default: return 0.0; } } 我们将语法分析器中的OutExprNode()函数换成GetExpValue()函数，这时候我们就能得到原点平移的横纵坐标的值origin_x和origin_y，横纵坐标放缩的值scale_x和scale_y，旋转的弧度值rot_ang，绘图时候参数T的起始值start、结束值end和步长step，但是现在注意了，FOR语句后面括号里面那两棵表达式树(struct ExprNode*)for_xptr,for_yptr里面带有参数T，所以我们不能直接在ForStatement()函数里面将这两棵表达式树的值求出来，而且根据要求，文件中Origin、Scale、Rot语句只影响它们后面的For语句，而且一个文件里面可以有多个FOR语句，所以我们在获得FOR语句括号里的两棵表达式树之后，我们要拿七个double容器将origin_x,origin_y,scale_x,scale_y,start,end,step装起来，拿两个struct ExprNode*容器将for_xptr和for_yptr装起来，这个时候这九个容器同一个下标里的内容就可以画出一个图形，ForStatement()函数改编后如下:\nvoid ForStatement(){ MatchToken(FOR); MatchToken(T); MatchToken(FROM); start_ptr = Expression(); start = GetExpValue(start_ptr); MatchToken(TO); end_ptr = Expression(); end = GetExpValue(end_ptr); MatchToken(STEP); step_ptr = Expression(); step = GetExpValue(step_ptr); MatchToken(DRAW); MatchToken(L_BRACKET); for_xptr = Expression(); For_X.push_back(for_xptr); MatchToken(COMMA); for_yptr = Expression(); For_Y.push_back(for_yptr); Origin_X.push_back(origin_x); Origin_Y.push_back(origin_y); Scale_X.push_back(scale_x); Scale_Y.push_back(scale_y); Rot_ang.push_back(rot_ang); Start.push_back(start); End.push_back(end); Step.push_back(step); MatchToken(R_BRACKET); } 现在我们有九个容器，每个容器都装着图形的一个参数，下一步就是来画图了。\n我利用的是EasyX，Clion下EasyX的配置教程参考: (8条消息) 在Clion中使用EasyX配置_Shine.Zhang的博客-CSDN博客\n只要能用\u0026lt;graphics.h\u0026gt;库就行了，各位自己去寻找导入方法吧。\n接下来先写一个画单个点的函数void DrawXY(double for_x, double for_y, double origin_x, double origin_y, double scale_x, double scale_y, double rot_ang)，传进去的是点的坐标、横纵坐标平移值、横纵坐标拉伸值以及旋转弧度值，代码如下:\nvoid DrawXY(double for_x, double for_y, double origin_x,double origin_y,double scale_x,double scale_y,double rot_ang){ double tempx, tempy; for_x *= scale_x; for_y *= scale_y; tempx = for_x; tempy = for_y; for_x = tempx * cos(rot_ang) + tempy * sin(rot_ang); for_y = tempy * cos(rot_ang) - tempx * sin(rot_ang); for_x += origin_x; for_y += origin_y; putpixel(for_x,for_y,RGB(255,255,255)); } 上面这段代码先将横纵坐标分别乘横纵坐标拉伸值，再根据旋转的规则:旋转后横坐标=旋转前横坐标cos(旋转弧度)+旋转前纵坐标sin(旋转弧度)，旋转后纵坐标=旋转前纵坐标cos(旋转弧度)-旋转前横坐标sin(旋转弧度) 将旋转后的横纵坐标求出来，再分别加上横纵坐标平移值，就得到了操作后的点，最后用putpixel()函数将点画出来。\n接下来我们就要通过循环令Parameter变量不断变化从而画出所有点，DrawTotalXY函数如下:\nvoid DrawTotalXY(Parsers P, double Origin_X,double Origin_Y,double Scale_X,double Scale_Y,double Rot_ang, double Start, double End, double Step, struct ExprNode* For_X, struct ExprNode* For_Y) { double x,y; Parameter = Start; if (Step \u0026gt; 0) { while (Parameter \u0026lt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); Parameter += Step; } } else if(Step \u0026lt; 0){ while (Parameter \u0026gt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); Parameter += Step; } } } 最后在main函数里面，我们通过下标从九个容器中取参数传到DrawTotalX函数里面画出所有的图像即可，完整代码如下，绘图器部分就完成了，这次上机也完成了。\n绘图器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdarg\u0026gt; #include \u0026lt;graphics.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } typedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; vector\u0026lt;double\u0026gt; Origin_X; vector\u0026lt;double\u0026gt; Origin_Y; vector\u0026lt;double\u0026gt; Scale_X; vector\u0026lt;double\u0026gt; Scale_Y; vector\u0026lt;double\u0026gt; Rot_ang; vector\u0026lt;double\u0026gt; Start; vector\u0026lt;double\u0026gt; End; vector\u0026lt;double\u0026gt; Step; vector\u0026lt;struct ExprNode*\u0026gt; For_X; vector\u0026lt;struct ExprNode*\u0026gt; For_Y; class Parsers{ public: Parsers(){LoadFileTokens();} struct ExprNode *origin_xptr, *origin_yptr, *scale_xptr, *scale_yptr, *rot_ptr, *start_ptr, *end_ptr, *step_ptr, *for_xptr, *for_yptr; double Parameter = 0, origin_x = 0, origin_y = 0, scale_x = 1, scale_y = 1, rot_ang = 0, start, end, step; static int cnt; Tokens TempToken; struct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } double GetExpValue(struct ExprNode* Tree) { if (Tree == NULL) return 0.0; switch (Tree-\u0026gt;OpCode) { case PLUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) + GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MINUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) - GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MUL: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) * GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case DIV: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) / GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case POWER: return pow(GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left), GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right)); case FUNC: return Tree-\u0026gt;Content.CaseFunc.MathFuncPtr(GetExpValue(Tree-\u0026gt;Content.CaseFunc.Child)); case CONST_ID: return Tree-\u0026gt;Content.CaseConst; case T: return *(Tree-\u0026gt;Content.CaseParmPtr); default: return 0.0; } } void FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Error Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Unexpected Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } void Parser(){ FetchToken(); Program(); } void Program(){ while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); } } void Statement(){ if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); } void OriginStatement(){ MatchToken(ORIGIN); MatchToken(IS); MatchToken(L_BRACKET); origin_xptr = Expression(); origin_x = GetExpValue(origin_xptr); MatchToken(COMMA); origin_yptr = Expression(); origin_y = GetExpValue(origin_yptr); MatchToken(R_BRACKET); } void RotStatement(){ MatchToken(ROT); MatchToken(IS); rot_ptr = Expression(); rot_ang = GetExpValue(rot_ptr); } void ScaleStatement(){ MatchToken(SCALE); MatchToken(IS); MatchToken(L_BRACKET); scale_xptr = Expression(); scale_x = GetExpValue(scale_xptr); MatchToken(COMMA); scale_yptr = Expression(); scale_y = GetExpValue(scale_yptr); MatchToken(R_BRACKET); } void ForStatement(){ MatchToken(FOR); MatchToken(T); MatchToken(FROM); start_ptr = Expression(); start = GetExpValue(start_ptr); MatchToken(TO); end_ptr = Expression(); end = GetExpValue(end_ptr); MatchToken(STEP); step_ptr = Expression(); step = GetExpValue(step_ptr); MatchToken(DRAW); MatchToken(L_BRACKET); for_xptr = Expression(); For_X.push_back(for_xptr); MatchToken(COMMA); for_yptr = Expression(); For_Y.push_back(for_yptr); Origin_X.push_back(origin_x); Origin_Y.push_back(origin_y); Scale_X.push_back(scale_x); Scale_Y.push_back(scale_y); Rot_ang.push_back(rot_ang); MatchToken(R_BRACKET); } struct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Term(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Factor(); while (TempToken.type == MUL || TempToken.type == DIV) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Factor(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Factor(){ struct ExprNode *left, *right; if(TempToken.type == PLUS){ MatchToken(PLUS); right = Factor(); left = NULL; right = MakeExprNode(PLUS,left,right); } else if(TempToken.type == MINUS){ MatchToken(MINUS); right = Factor(); left = MakeExprNode(CONST_ID,0.0); right = MakeExprNode(MINUS,left,right); } else right = Component(); return right; } struct ExprNode* Component(){ struct ExprNode *left, *right; left = Atom(); if(TempToken.type == POWER){ MatchToken(POWER); right = Component(); left = MakeExprNode(POWER,left,right); } return left; } struct ExprNode* Atom(){ struct ExprNode *address, *tmp; double const_value; FuncPtr funcPtr_value; if(TempToken.type == CONST_ID){ const_value = TempToken.value; MatchToken(CONST_ID); address = MakeExprNode(CONST_ID,const_value); } else if(TempToken.type == T){ MatchToken(T); address = MakeExprNode(T); } else if(TempToken.type == FUNC){ funcPtr_value = TempToken.FuncPtr; MatchToken(FUNC); MatchToken(L_BRACKET); tmp = Expression(); address = MakeExprNode(FUNC,funcPtr_value,tmp); MatchToken(R_BRACKET); } else if(TempToken.type == L_BRACKET){ MatchToken(L_BRACKET); address = Expression(); MatchToken(R_BRACKET); } else SyntaxError(2); return address; } }; int Parsers::cnt = 0; void DrawXY(double for_x, double for_y, double origin_x,double origin_y,double scale_x,double scale_y,double rot_ang){ double tempx, tempy; for_x *= scale_x; for_y *= scale_y; tempx = for_x; tempy = for_y; for_x = tempx * cos(rot_ang) + tempy * sin(rot_ang); for_y = tempy * cos(rot_ang) - tempx * sin(rot_ang); for_x += origin_x; for_y += origin_y; putpixel(for_x,for_y,RGB(255,255,255)); } void DrawTotalXY(Parsers P, double Origin_X,double Origin_Y,double Scale_X,double Scale_Y,double Rot_ang, double Start, double End, double Step, struct ExprNode* For_X, struct ExprNode* For_Y) { double x,y; P.Parameter = Start; if (Step \u0026gt; 0) { while (P.Parameter \u0026lt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); P.Parameter += Step; } } else if(Step \u0026lt; 0){ while (P.Parameter \u0026gt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); P.Parameter += Step; } } } int main() { Parsers P; P.Parser(); initgraph(1000, 700); for(int i = 0; i \u0026lt; Start.size(); i ++) DrawTotalXY(P,Origin_X[i],Origin_Y[i],Scale_X[i],Scale_Y[i],Rot_ang[i],Start[i],End[i],Step[i],For_X[i],For_Y[i]); _getch(); closegraph(); return 0; } ","date":"2022/11/21","externalUrl":null,"permalink":"/blogs/fglcompiler3/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器C++实现 - Part 3 - 绘图器","title":"编译原理上机(三) - 绘图器","type":"blogs"},{"content":"西电编译原理大作业 - 函数绘图语言编译器C++实现 - Part 2 - 语法分析器\nauthor: En1y\ntime:2022-11-19\nschool:Xidian university\n第二部分:语法分析器(完整代码在结尾)\n测试文本:\norigin is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 语法分析器的目的是判断词法分析器得到的记号是否合法，以及记号组成的句子是否合法。\n语法分析器的设计思路:\n​ 比如文本里装的是:\n​ ORIGIN IS (-16+5**3/cos(pi),2*120);\n​ 我们通过第一部分的词法分析器就能得到一个记号流:\n​ ORIGIN IS L_BRACKET CONST_ID MUL CONST_ID COMMA CONST_ID MUL CONST_ID R_BRACKET SEMICO\n​ 我们现在从记号流里面取出第一个记号ORIGIN，所以我们要匹配OriginStatement，继续取下一个记号，要想符合OriginStatement的语法，下一个记号应该匹配IS，如果下一个记号不能匹配IS，那就语法报错后退出；如果下一个记号匹配的是IS，我们就继续匹配，如果我们在匹配过程中取到了ERRTOKEN类型的记号，那么就词法报错后退出。\n​ 所以设计思路就是:\n​ 依次取记号，如果是ERRTOKEN类型就词法报错，如果匹配不了语法，那就语法报错。\n​ 需要注意到的是括号和逗号之间的是两个表达式，所以我们要设计一个表达式树结构，比如给的这个例子我们匹配完左括号之后，要生成一个表达式树来表示-16+5**3/cos(pi)。\n表达式树的节点可以分为三类:\n​ 1.叶节点: 常数CONST_ID、参数T\n​ 2.有两个孩子的节点 也就是运算符节点: 加PLUS、减MINUS、乘MUL、除DIV、幂运算POWER (这时候有两个特例就是一元加和一元减，比如+5，这个+的左孩子就是NULL，右孩子是5，就将+5转换成5了；还有-5，这个-的左孩子就是0，右孩子就是5，就将-5转换成0-5了)\n​ 3.有一个孩子的节点 也就是函数节点: 函数FUNC\n表达式树节点代码:\ntypedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; 表达式树节点的生成，本来我是根据匹配的记号类型的不同设计四个函数生成不同类型的节点，但是PPT上给出的利用可变列表生成节点的方法更简便，代码如下。 这段代码的意思是: 如果现在匹配的是常数CONST_ID类型，那我们传进去的肯定是常数的值value，我们就可以生成一个节点，这个节点的CaseConst指针指向常数的值；如果我们匹配的是参数T类型，那就生成一个节点，这个节点的CaseParmPtr指针指向Parameter；如果我们匹配的是函数FUNC类型，那我们传进去的肯定是一个函数指针以及一个表达式树节点，那就可以生成一个节点，这个节点的MathFuncPtr指针指向传入的函数，Child孩子指针指向传入的表达式树节点；如果我们匹配的是运算符例如PLUS/MINUS这些类型，那我们传进去的肯定是两个表达式节点，那就可以生成一个节点，这个节点的Left左孩子指针指向传入的第一个节点，Right右孩子指针指向传入的第二个节点。\nstruct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } 利用递归进行表达式树的打印，注意一下，上面两段代码都是表达式树的节点的设计和生成，下面的代码是打印一整棵表达式树。通过递归先序遍历打印表达式树：传入表达式树的根节点，如果节点类型是CONST_ID那就说明这个节点只有CaseConst指针有值，打印CaseConst指针指向的值；如果节点类型是T那就打印\u0026quot;T\u0026quot;；如果节点类型是FUNC那就说明这个节点的MathFuncPtr和Child指针有值，先根据MathFuncPtr指向的函数打印函数的名称，然后用递归打印以孩子节点作为根节点的子树；如果节点类型是运算符，那就先打印运算符，然后递归打印分别以左右孩子节点为根节点的两棵子树。\nvoid OutExprNode(struct ExprNode* Tree){ cout \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34;; switch (Tree-\u0026gt;OpCode) { case CONST_ID: cout \u0026lt;\u0026lt; Tree-\u0026gt;Content.CaseConst \u0026lt;\u0026lt; endl;break; case T: cout \u0026lt;\u0026lt; \u0026#34;T\u0026#34; \u0026lt;\u0026lt; endl;break; case FUNC:{ if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sin){cout \u0026lt;\u0026lt; \u0026#34;sin\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = cos){cout \u0026lt;\u0026lt; \u0026#34;cos\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = log){cout \u0026lt;\u0026lt; \u0026#34;log\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = exp){cout \u0026lt;\u0026lt; \u0026#34;exp\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = tan){cout \u0026lt;\u0026lt; \u0026#34;tan\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sqrt){cout \u0026lt;\u0026lt; \u0026#34;sqrt\u0026#34; \u0026lt;\u0026lt; endl;} OutExprNode(Tree-\u0026gt;Content.CaseFunc.Child); }break; case PLUS:{ cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MINUS:{ cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MUL:{ cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case DIV:{ cout \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case POWER:{ cout \u0026lt;\u0026lt; \u0026#34;**\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; } } 绘图语言的文法:\nProgram -\u0026gt; { Statement SEMICO }\nStatement -\u0026gt; OriginStatement | ScaleStatement | RotStatement | ForStatement\nOriginStatement -\u0026gt; ORIGIN IS L_BRACKET Expression COMMA Expression R_BRACKET\nScaleStatement -\u0026gt; SCALE IS L_BRACKET Expression COMMA Expression R_BRACKET\nRotStatement -\u0026gt; ROT IS Expression\nForStatement -\u0026gt; FOR T FROM Expression TO Expression STEP Expression DRAW L_BRACKET Expression COMMA Expression R_BRACKET\n表达式树的产生式:\nExpression -\u0026gt; Term { ( PLUS | MINUS ) Term }\nTerm -\u0026gt; Factor { ( MUL | DIV ) Factor }\nFactor -\u0026gt; PLUS Factor | MINUS Factor | Component\nComponent -\u0026gt; Atom POWER Component | Atom\nAtom -\u0026gt; CONST_ID | T | FUNC L_BRACKET Expression R_BRACKET | L_BRACKET Expression R_BRACKET\n根据绘图语言文法和表达式树的产生式，我们可以设计一个Parsers类，在类里利用迭代实现文法和表达式树的产生。\nParsers类里我们首先定义一个构造函数 Parsers(){LoadFileTokens();} 作用是当我们创建一个Parsers类实例的时候自动调用LoadFileTokens()函数将文本的记号流装到容器里。\n先写三个辅助函数\nvoid FetchToken();\nvoid MatchToken(Token_Type t);\nvoid SyntaxError(int x);\nvoid FetchToken(); 这个函数的作用是从记号流里获取一个记号，如果获取的记号是ERRTOKEN类，就词法报错后退出\nvoid FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t); 这个函数的参数是一个单词类型，作用是将当前从记号流里获取的记号和这个单词类型进行匹配，如果不匹配就语法报错后退出，否则就获取下一个记号\nvoid MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x); 这个函数的参数是一个整数，如果整数是1就代表词法错误，如果整数是2就代表语法错误\nvoid SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No: \u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; 有一个错误记号: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No: \u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; 有一个不是预期的记号: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } 根据上面给出的文法和表达式树的产生式，我们利用迭代实现文法和表达式树的生成，我们需要下列函数\nvoid Parser();\nvoid Program();\nvoid Statement();\nvoid OriginStatement();\nvoid ScaleStatement();\nvoid ForStatement();\nvoid RotStatement();\nstruct ExprNode* Expression();\nstruct ExprNode* Term();\nstruct ExprNode* Factor();\nstruct ExprNode* Component();\nstruct ExprNode* Atom();\nParser()函数获取第一个记号，然后进入Program()函数\nvoid Parser(){ FetchToken(); Program(); } 根据上述文法 Program -\u0026gt; { Statement SEMICO }\n我们写一个 Program()函数，如下:\nvoid Program(){ while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); } } 根据上述文法 Statement -\u0026gt; OriginStatement | ScaleStatement | RotStatement | ForStatement\n我们写一个Statement()函数，如下:\nvoid Statement(){ if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); } 根据上述文法 OriginStatement -\u0026gt; ORIGIN IS L_BRACKET Expression COMMA Expression R_BRACKET\n我们写一个OriginStatement()函数，如下：// ScaleStatement()、RotStatement()、ForStatement()这三个函数根据上述文法可以类比OriginStatement()函数写一下\nvoid OriginStatement(){ MatchToken(ORIGIN); MatchToken(IS); MatchToken(L_BRACKET); origin_xptr = Expression(); MatchToken(COMMA); origin_yptr = Expression(); MatchToken(R_BRACKET); } 根据上面表达式树的产生式第一条\nExpression -\u0026gt; Term { ( PLUS | MINUS ) Term }\n写一个struct ExprNode* Expression()函数，如下:\nstruct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } 其他表达式树生成函数跟Expression()函数类似，根据上面表达式树的产生式可以类比Expression()函数依次写出来，不想分析了，放在底下完整代码里了，第二部分语法分析器结束。\n语法分析器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdarg\u0026gt; #include \u0026lt;graphics.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } typedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; class Parsers{ public: Parsers(){LoadFileTokens();} double Parameter = 0; struct ExprNode *origin_xptr, *origin_yptr, *scale_xptr, *scale_yptr, *rot_ptr, *start_ptr, *end_ptr, *step_ptr, *for_xptr, *for_yptr; static int cnt; Tokens TempToken; struct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } void OutExprNode(struct ExprNode* Tree){ cout \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34;; switch (Tree-\u0026gt;OpCode) { case CONST_ID: cout \u0026lt;\u0026lt; Tree-\u0026gt;Content.CaseConst \u0026lt;\u0026lt; endl;break; case T: cout \u0026lt;\u0026lt; \u0026#34;T\u0026#34; \u0026lt;\u0026lt; endl;break; case FUNC:{ if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sin){cout \u0026lt;\u0026lt; \u0026#34;sin\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = cos){cout \u0026lt;\u0026lt; \u0026#34;cos\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = log){cout \u0026lt;\u0026lt; \u0026#34;log\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = exp){cout \u0026lt;\u0026lt; \u0026#34;exp\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = tan){cout \u0026lt;\u0026lt; \u0026#34;tan\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sqrt){cout \u0026lt;\u0026lt; \u0026#34;sqrt\u0026#34; \u0026lt;\u0026lt; endl;} OutExprNode(Tree-\u0026gt;Content.CaseFunc.Child); }break; case PLUS:{ cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MINUS:{ cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MUL:{ cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case DIV:{ cout \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case POWER:{ cout \u0026lt;\u0026lt; \u0026#34;**\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; } } void FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Error Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Unexpected Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } void Parser(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Parser\u0026#34; \u0026lt;\u0026lt; endl; FetchToken(); Program(); cout \u0026lt;\u0026lt; \u0026#34;exit from Parser\u0026#34; \u0026lt;\u0026lt; endl; } void Program(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Program\u0026#34; \u0026lt;\u0026lt; endl; while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ;\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;exit from Program\u0026#34; \u0026lt;\u0026lt; endl; } void Statement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Statement\u0026#34; \u0026lt;\u0026lt; endl; if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); cout \u0026lt;\u0026lt; \u0026#34;exit from Statement\u0026#34; \u0026lt;\u0026lt; endl; } void OriginStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in OriginStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(ORIGIN); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ORIGIN\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; origin_xptr = Expression(); OutExprNode(origin_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; origin_yptr = Expression(); OutExprNode(origin_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from OriginStatement\u0026#34; \u0026lt;\u0026lt; endl; } void RotStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in RotStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(ROT); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ROT\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; rot_ptr = Expression(); OutExprNode(rot_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from RotStatement\u0026#34; \u0026lt;\u0026lt; endl; } void ScaleStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in ScaleStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(SCALE); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken SCALE\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; scale_xptr = Expression(); OutExprNode(scale_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; scale_yptr = Expression(); OutExprNode(scale_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from ScaleStatement\u0026#34; \u0026lt;\u0026lt; endl; } void ForStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in ForStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(FOR); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken FOR\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(T); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken T\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(FROM); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken FROM\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; start_ptr = Expression(); OutExprNode(start_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(TO); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken TO\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; end_ptr = Expression(); OutExprNode(end_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(STEP); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken STEP\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; step_ptr = Expression(); OutExprNode(step_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(DRAW); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken DRAW\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; for_xptr = Expression(); OutExprNode(for_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; for_yptr = Expression(); OutExprNode(for_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from ForStatement\u0026#34; \u0026lt;\u0026lt; endl; } struct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Term(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Factor(); while (TempToken.type == MUL || TempToken.type == DIV) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Factor(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Factor(){ struct ExprNode *left, *right; if(TempToken.type == PLUS){ MatchToken(PLUS); right = Factor(); left = NULL; right = MakeExprNode(PLUS,left,right); } else if(TempToken.type == MINUS){ MatchToken(MINUS); right = Factor(); left = MakeExprNode(CONST_ID,0.0); right = MakeExprNode(MINUS,left,right); } else right = Component(); return right; } struct ExprNode* Component(){ struct ExprNode *left, *right; left = Atom(); if(TempToken.type == POWER){ MatchToken(POWER); right = Component(); left = MakeExprNode(POWER,left,right); } return left; } struct ExprNode* Atom(){ struct ExprNode *address, *tmp; double const_value; FuncPtr funcPtr_value; if(TempToken.type == CONST_ID){ const_value = TempToken.value; MatchToken(CONST_ID); address = MakeExprNode(CONST_ID,const_value); } else if(TempToken.type == T){ MatchToken(T); address = MakeExprNode(T); } else if(TempToken.type == FUNC){ funcPtr_value = TempToken.FuncPtr; MatchToken(FUNC); MatchToken(L_BRACKET); tmp = Expression(); address = MakeExprNode(FUNC,funcPtr_value,tmp); MatchToken(R_BRACKET); } else if(TempToken.type == L_BRACKET){ MatchToken(L_BRACKET); address = Expression(); MatchToken(R_BRACKET); } else SyntaxError(2); return address; } }; int Parsers::cnt = 0; int main() { Parsers P; P.Parser(); return 0; } ","date":"2022/11/20","externalUrl":null,"permalink":"/blogs/fglcompiler2/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器C++实现 - Part 2 - 语法分析器","title":"编译原理上机(二) — 语法分析器","type":"blogs"},{"content":"西电编译原理大作业 - 函数绘图语言编译器C++实现 - Part 1 - 词法分析器\nauthor : Enly\ntime : 2022-11-19\nschool : Xidian university\n写在前头:\n下面给出的代码是我第一版写出来的，勉强能符合要求。我后来进行了代码的优化和功能的添加，希望各位能够借鉴我的思路自己写一遍。\n上机目的:\n例如: ORIGIN IS (360,240); \u0026ndash; 将原点平移到(360,240)位置\n​ SCALE IS (100,100); // 将横坐标和纵坐标都放大100倍\n​ SCALE IS (100,100/3); \u0026ndash; 横坐标放大100倍，纵坐标放大100/3倍\n​ ROT IS PI/2; // 图形逆时针旋转90度\n​ FOR T FROM 0 TO 2PI STEP PI/50 DRAW(cos(T),sin(T)); //画圆\n​ 这是给定的一个绘图语言，有四种语句。ORIGIN语句，作用是将原点平移；SCALE语句，作用是将横纵坐标放大；ROT语句，作用是将图形旋转；FOR语句，作用是画图；还有\u0026ndash;和//，作用是注释。\n所以上机分三个部分:\n​ (1) 词法分析器:目的是将这些语句中的单词一个个识别出来\n​ (2) 语法分析器:目的是判断词法分析器得到的单词是否有错误，以及识别到的单词组成的语句符不符合规定\n​ (3) 绘图器:通过识别到的语句进行画图\n第一部分:词法分析器 (完整代码在结尾)\n测试文本:\norigin is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 ​ 词法分析器的目的说白了就是将文件中的单词一个个提取出来并分类\n比如:ORIGIN IS (360,240); 将这个句子中的单词提取出来就是ORIGIN、IS、(、360、,、240、)、; 我们将提取到的单词进行分类，比如360和240就是同一类都是常数，于是我们可以将单词的种类分为:\n​ 保留字: ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,T\n​ 分隔符: SEMICO(;),L_BRACKET((),R_BRACKET()),COMMA(,)\n​ 运算符: PLUS(+),MINUS(-),MUL(*),DIV(/),POWER(**)\n​ 参数: T\n​ 函数: FUNC\n​ 常数: CONST_ID\n​ 结尾记号: NONTOKEN\n​ 出错记号: ERRTOKEN\n我们利用一个枚举enum类型来将单词的种类给装起来:\nenum Token_Type { ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //结尾记号 ERRTOKEN //出错记号 }; 单词有自己的属性，上面我们用enum装起来的只是单词的一个单词种类属性，单词还有文本属性，常数还有自己的值属性，函数还有自己的函数指针属性，还有每个单词在文件中的行数属性。比如Origin这个单词，它的单词种类是ORIGIN，文本是Origin，它不是常数所以值属性规定为0，也不是函数所以函数指针设为NULL；再比如360这个单词，它的单词种类是CONST_ID，文本是360，它是常数所以值属性为360，它不是函数所以函数指针设为NULL;再比如sin这个单词，它的单词种类是FUNC，文本是sin，它不是常数所以值属性为0，它是函数所以函数指针设为sin。\n所以我们用struct定义一个单词结构体:\ntypedef struct Tokens { Token_Type type; //单词种类 string lexeme; //单词的文本 double value; // 常数单词的值 double (*FuncPtr)(double); // 函数单词的函数指针 int TokenLine; // 单词在文件中的行数 } Tokens; 这时候我们意识到一个问题，当我们在文件里识别到Origin、Scale、sin、Pi这些字符串单词的时候我们要给它归类到保留字、函数、常数等我们预先定义的单词类型，但当我们识别到abcd、xyz这些字符串单词的时候，我们要给这些单词归类到ERRTOKEN类型。所以我们需要一个单词字典，当我们识别到字符串单词的时候，要先查找这个单词字典，如果在字典里没有找到，我们就要将它们归类到ERRTOKEN类型。\n所以我们定义一个单词字典:\nstatic Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; 利用C++的类，我们定义一个Scanner类。\n这个类里有三个成员变量:\n​ string FileName;\n​ string TokenBuffer;\n​ fstream F;\n其中TokenBuffer是字符串缓冲区，因为我们读文件是利用循环一个字符一个字符地读，所以我们要有一个字符串缓冲区来将字符一个个装起来。比如文件里有个Origin单词，我们读文件时，先读到一个O字母，我们把O装到缓冲区，然后再读r字母，再装到缓冲区，以此类推，到最后读完这个单词的时候，缓冲区就装了Origin这个单词的文本值了。\n类里还有七个成员函数:\n​ void OpenFile();\n​ void CloseFile();\n​ void EmptyBuffer();\n​ void AddCharToBuffer(char TempC);\n​ Tokens SearchCharInDict(string TempS);\n​ Tokens CreateTokens(Token_Type type,string lexeme,double value,double (*FuncPtr)(double),int Line);\n​ Tokens GetToken();\n接下来我依次来说明这些成员函数的作用:\nvoid OpenFile(); 这个函数作用很简单，就是输入文件名后打开文件。\nvoid OpenFile(){ // 输入文件名打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(); 这个函数就是关闭文件。\nvoid CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(); 这个函数的作用是清空缓冲区，读上一个单词的时候上一个单词的文本值还在缓冲区里面，我们读下一个单词的时候就要先清空缓冲区。\nvoid EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC); 这个函数的作用就是将一个字符装到缓冲区里面。\nvoid AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS); 这个函数的作用是查单词字典，上面我们说过了，当我们读字符串单词的时候，要先在单词字典里面进行查找，如果没找到的话要将其归类为ERRORTOKEN类型。任务规定语言对大小写不敏感，所以Origin,origin,ORIGIN都要识别为ORIGIN类型，所以我们将存在缓冲区的单词文本值传进去的时候，将其全部转换为大写字母，我这里是利用C++自带的算法库进行大写转换的。\nTokens SearchCharInDict(string TempS){ //查单词字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; //利用C++算法库进行大写转换 transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme) { T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateTokens(Token_Type type,string lexeme,double value,double (*FuncPtr)(double),int Line); 这个函数作用是传入单词的各个属性，返回一个单词，因为底下GetToken()函数在生成单词时有很多重复代码，所以就专门写了个函数进行单词生成。\nTokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ // 生成单词 Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(); 这个函数是Scanner类最核心的成员函数，作用是获取文件中的一个单词。\n设计思路:我们读文件是一个字符一个字符地读。所以我们根据读到的字符进行不同的设计。\n​ 当我们读到的字符是文件结尾字符 \u0026lsquo;EOF\u0026rsquo; 的时候，我们返回一个类型为NONTOKEN的单词。\n​ 当我们读到的字符是空格 \u0026rsquo; \u0026rsquo; 或者制表符 \u0026lsquo;\\t\u0026rsquo; 的时候，不作处理，继续读下一个字符。\n​ 当我们读到的字符是换行符 \u0026lsquo;\\n\u0026rsquo; 的时候，我们将行数加1，然后继续读下一个字符。\n​ 当我们读到的字符是字母 \u0026lsquo;[a-zA-Z]\u0026rsquo; 的时候，我们将字符装到缓冲区，然后读下一个字符，如果下一个字符还是字母，那就继续装到缓冲区，直到读的字符不是字母为止，这个时候缓冲区里面装的就是单词的文本值了。然后查单词字典，是预设的单词的话就返回一个预设的单词，不然就返回一个类型为ERRTOKEN的单词。\n​ 当我们读到的字符是数字 \u0026lsquo;[0-9]\u0026rsquo; 的时候，我们将字符装到缓冲区，然后读下一个字符，如果下一个字符还是数字，就继续装到缓冲区，直到读的字符不是数字为止。由于数字还能有小数，所以这时候如果读的字符是小数点 \u0026lsquo;.\u0026rsquo; ，那就继续装到缓冲区，然后读下一个字符，如果是数字就装到缓冲区，直到读的字符不是数字为止，这个时候缓冲区里面就是常数的文本值。最后返回一个类型为CONST_ID，值属性为利用stod()函数转换缓冲区里的文本值为常数值 的单词。\n​ 当我们读到的字符是分号 \u0026lsquo;;\u0026rsquo; 的时候，返回一个类型为SEMICO的单词。\n​ 当我们读到的字符是左括号 \u0026lsquo;(\u0026rsquo; 的时候，返回一个类型为L_BRACKET单词。\n​ 当我们读到的字符是分号右括号 \u0026lsquo;)\u0026rsquo; 的时候，返回一个类型为R_BRACKET的单词。\n​ 当我们读到的字符是逗号 \u0026lsquo;,\u0026rsquo; 的时候，返回一个类型为COMMA的单词。\n​ 当我们读到的字符是加号 \u0026lsquo;+\u0026rsquo; 的时候，返回一个类型为PLUS的单词。\n​ 当我们读到的字符是减号 \u0026lsquo;-\u0026rsquo; 的时候，由于 \u0026ndash; 是注释，我们需要继续读下一个字符，如果下一个字符不是 \u0026lsquo;-\u0026rsquo;，那么我们返回一个类型为MINUS的单词，如果下一个字符是 \u0026lsquo;-\u0026rsquo;，我们就要继续往后读，直到读的字符是换行符 \u0026lsquo;\\n\u0026rsquo; 或者结束符 \u0026lsquo;EOF\u0026rsquo; 的时候结束，要是读的是 \u0026lsquo;\\n\u0026rsquo;就将行数加1然后继续下一个循环，要是读的是 \u0026lsquo;EOF\u0026rsquo; 就返回一个类型为NONTOKEN的单词。\n​ 当我们读到的字符是除号 \u0026lsquo;/\u0026rsquo; 的时候，跟读减号 \u0026lsquo;-\u0026rsquo; 的方法一样\n​ 当我们读到的字符是乘号 \u0026lsquo;*\u0026rsquo; 的时候，由于 * 是幂次运算，我们需要继续读下一个字符，如果下一个字符不是 \u0026lsquo;*\u0026rsquo;，那么我们返回一个类型为MUL的单词，如果下一个字符是 \u0026lsquo;*\u0026rsquo;，我们就返回一个类型为POWER的单词。*\nTokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;){ c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } Scanner类我们就已经设计好了，这个时候我选择用一个循环反复调用GetToken()函数将文件里面的所有单词存放到一个容器里面，后面设计语法分析器的时候就可以直接从容器里面取了，不过这也是看个人喜好，用一次调一次GetToken()函数也可以。\nvector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens() { Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } 再然后就是打印所有单词了，就不写了，直接放到完整代码里面，词法分析器部分就结束了。\n词法分析器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iomanip\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } void Cout(string type, string lexeme, double value, string funcptr){ cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; type \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; lexeme \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(14) \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(16) \u0026lt;\u0026lt; funcptr \u0026lt;\u0026lt; endl; } void COUT(Tokens t){ switch (t.type) { case ORIGIN:Cout(\u0026#34;ORIGIN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case SCALE:Cout(\u0026#34;SCALE\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case ROT:Cout(\u0026#34;ROT\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case IS:Cout(\u0026#34;IS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case TO:Cout(\u0026#34;TO\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case STEP:Cout(\u0026#34;STEP\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case DRAW:Cout(\u0026#34;DRAW\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FOR:Cout(\u0026#34;FOR\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FROM:Cout(\u0026#34;FROM\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case T:Cout(\u0026#34;T\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case SEMICO:Cout(\u0026#34;SEMICO\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case L_BRACKET:Cout(\u0026#34;L_BRACKET\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case R_BRACKET:Cout(\u0026#34;R_BRACKET\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case COMMA:Cout(\u0026#34;COMMA\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case PLUS:Cout(\u0026#34;PLUS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case MINUS:Cout(\u0026#34;MINUS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case MUL:Cout(\u0026#34;MUL\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case DIV:Cout(\u0026#34;DIV\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case POWER:Cout(\u0026#34;POWER\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FUNC:{ string temp = t.lexeme; transform(temp.begin(),temp.end(),temp.begin(),::toupper); Cout(\u0026#34;FUNC\u0026#34;,t.lexeme,t.value,temp); };break; case CONST_ID:Cout(\u0026#34;CONST_ID\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; case NONTOKEN:Cout(\u0026#34;NONTOKEN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; case ERRTOKEN:Cout(\u0026#34;ERRTOKEN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; } } int main() { LoadFileTokens(); cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; \u0026#34;Token_Type\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; \u0026#34;String_Value\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(14) \u0026lt;\u0026lt; \u0026#34;Constant_Value\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(16) \u0026lt;\u0026lt; \u0026#34;Function_Pointer\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-------------------------------------------------------------------------------------\u0026#34; \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; TokenStream.size(); i ++) COUT(TokenStream[i]); return 0; } ","date":"2022/11/19","externalUrl":null,"permalink":"/blogs/fglcompiler1/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器C++实现 - Part 1 - 词法分析器","title":"编译原理上机（一) - 词法分析器","type":"blogs"},{"content":"","date":"0001/1/1","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]