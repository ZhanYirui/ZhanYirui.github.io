
[{"content":"","date":"2024/6/29","externalUrl":null,"permalink":"/tags/afl++/","section":"Tags","summary":"","title":"AFL++","type":"tags"},{"content":"","date":"2024/6/29","externalUrl":null,"permalink":"/blogs/","section":"Blogs","summary":"","title":"Blogs","type":"blogs"},{"content":"","date":"2024/6/29","externalUrl":null,"permalink":"/","section":"Enly","summary":"","title":"Enly","type":"page"},{"content":"","date":"2024/6/29","externalUrl":null,"permalink":"/tags/fuzzing/","section":"Tags","summary":"","title":"Fuzzing","type":"tags"},{"content":"MacOS系统M芯片利用AFL++进行模糊测试教程\n1.下载Docker # Docker下载链接：https://docs.docker.com/desktop/install/mac-install/\n选择Docker Desktop for Mac with Apple sillicon\n下载完成后进行安装\n安装后打开，点击右上角的设置按钮\n点击Docker Engine，将下面的json内容替换掉原先的内容，完成换源后点击右下角的Apply\u0026amp;restart重启\n{ \u0026#34;builder\u0026#34;: { \u0026#34;gc\u0026#34;: { \u0026#34;defaultKeepStorage\u0026#34;: \u0026#34;20GB\u0026#34;, \u0026#34;enabled\u0026#34;: true } }, \u0026#34;experimental\u0026#34;: false, \u0026#34;features\u0026#34;: { \u0026#34;buildkit\u0026#34;: true }, \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://hub-mirror.c.163.com\u0026#34; ] } 2.克隆AFL++到本地 # 首先我们可以创建一个afl++目录用于存放AFL++项目，然后进入这个目录进行git clone\nmkdir afl++ cd afl++ git clone https://github.com/AFLplusplus/AFLplusplus 完成上面三步，AFL++项目就被克隆到了本地\n3.创建一个AFL++容器 # 打开终端，输入以下命令，将aflplusplus镜像拉到本地\ndocker pull aflplusplus/aflplusplus 然后，根据镜像创建一个AFL++容器\ndocker run -it aflplusplus/aflplusplus /bin/bash 这时候应该是在/AFLplusplus目录下，我们用make命令进行编译构建\nmake 4.将要测试的代码导入容器 # 这里我将要测试的代码放到了我的github仓库里，然后利用git clone将代码文件克隆到容器内，直接从本地导入代码文件的方法自寻查找 由于现在是在/AFLplusplus目录下，我们先返回上一级目录\ncd .. 然后利用git clone将代码文件克隆下来\ngit clone https://github.com/ZhanYirui/Fuzzing_Test_File.git 然后进入你存放代码的目录下\ncd /Fuzzing_Test_File/test1 创建一个构建目录并进入\nmkdir build cd build 将AFL++工具添加到可执行文件的编译器中\nCC=/AFLplusplus/afl-clang-fast CXX=/AFLplusplus/afl-clang-fast++ cmake .. 制作构建中的文件\nmake 我们需要一个种子目录，这个种子目录你可以根据代码精心构造，我这里是随机初始种子\ncd .. mkdir seeds cd seeds for i in {0..4}; do dd if=/dev/urandom of=seed_$i bs=64 count=10; done cd .. cd build 拥有种子目录后，就可以进行测试了，输入以下命令\n/AFLplusplus/afl-fuzz -i [full path to your seeds directory] -o out -m none -d -- [full path to the executable] 其中[full path to your seeds directory]是种子目录的路径，[full path to the executable]是你build的可执行文件的路径，比如我这里就是：\n/AFLplusplus/afl-fuzz -i /Fuzzing_Test_File/test1/seeds -o out -m none -d -- /Fuzzing_Test_File/test1/build/simple_crash 然后就可以看到AFL++在进行测试了\n可以通过control + C来退出fuzzing，并通过out/default/crashes目录来找到导致程序崩溃的输入\n5.利用Sourcetail分析源代码 # sourcetail是一个很好用的源码阅读工具\nsourcetail下载链接：https://github.com/CoatiSoftware/Sourcetrail/releases\n","date":"2024/6/29","externalUrl":null,"permalink":"/blogs/aflplusinstall/","section":"Blogs","summary":"MacOS系统M芯片利用AFL++进行模糊测试教程","title":"MacOS系统M芯片利用AFL++进行模糊测试教程","type":"blogs"},{"content":"","date":"2024/6/29","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024/6/8","externalUrl":null,"permalink":"/tags/%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/","section":"Tags","summary":"","title":"软件与系统安全","type":"tags"},{"content":"软件与系统安全笔记(8) - 木马\n木马 # 木马分类 # 破坏型\n旨在直接对受感染的计算机系统造成损害，如删除或篡改文件，格式化硬盘，或使系统变得不稳定，无法正常运行。\n密码发送型\n专门设计用于窃取用户的登录凭证，如网上银行密码、社交账户信息等，并将这些信息发送给攻击者。\n远程访问型\n给予攻击者对受害者计算机的完全控制权，允许他们执行任意命令、浏览文件、监控屏幕、激活摄像头和麦克风等，如同亲自操作该电脑一样。\n键盘记录木马\n记录受害者的键盘输入，常用于窃取登录凭据、信用卡信息等敏感数据，是密码盗窃的一种具体形式。\nDos攻击木马\n这类木马将受感染的计算机转变为“僵尸网络”的一部分，协同发起拒绝服务攻击，淹没目标服务器或网络，使其无法响应合法请求。\n代理木马\n将受害者的计算机变为攻击者的代理服务器，用来隐藏攻击者的真实身份，进行匿名上网或进一步的恶意活动。\nFTP木马\n创建一个FTP服务器在受害者的计算机上，使得攻击者能够通过FTP协议自由上传和下载文件，便于植入更多恶意代码或窃取数据。\n程序杀手木马\n能够终止或禁用特定的系统进程或安全软件（如防病毒软件），以降低系统的防御能力，便于其他恶意软件的渗透和活动。\n反弹端口木马\n传统木马需要攻击者主动向被控制计算机上的木马程序发起连接，而反弹端口型木马是被控计算机上的木马向攻击者发起连接，可以用于绕过防火墙等安全软件。\n木马特点 # 有效性\n指木马必须能够成功完成其设计的恶意任务，无论是窃取数据、控制系统还是执行其他恶意行为，有效性是衡量木马是否达到其目的的基本标准。\n隐蔽性\n这是木马的核心特征之一，它必须能够在不引起用户或安全软件警觉的情况下潜伏、运行和传播。这通常通过模仿正常程序的行为、隐藏自身文件或进程、修改系统设置等方式实现。\n顽固性\n指木马难以被发现和清除的特性。一些木马会自我复制、修改注册表项、备份自身到多个位置或在系统启动时自动加载，以确保即使部分被删除也能重新激活。\n易植入性\n木马设计要便于通过多种渠道传播，如电子邮件附件、恶意下载链接、社交媒体、软件捆绑等，易于诱导用户无意中下载安装。\n自动运行\n确保木马能在操作系统启动时自动执行，无需用户干预，这是确保其持久驻留和执行恶意活动的关键。\n欺骗性\n木马通常会伪装成有用的、合法的或吸引人的程序，如游戏外挂、系统更新通知、安全扫描工具等，以此欺骗用户下载安装。\n自动恢复\n即使被发现或部分移除，木马能够通过自我修复或重新下载机制恢复，增加清除难度，保持其在系统中的存在。\n功能的特殊性\n不同的木马可能专注于特定的恶意行为，如密码窃取、远程控制、数据加密（勒索软件）、DDoS攻击等，这些特殊功能使得木马能够针对特定目标或需求定制，提高攻击效率。\n木马实现原理 # 木马程序是一对C/S程序的组合：\n一个攻击者控制的客户端程序 一个运行在被控主机上的服务端程序 利用木马实现入侵需要完成以下环节：\n向目标主机植入服务端程序\n攻击者首先需要将服务端程序安装到目标计算机上。这可以通过多种途径实现，包括但不限于：电子邮件附件、恶意下载链接、软件捆绑、社交媒体诈骗、利用系统漏洞或弱口令入侵等。\n启动和隐藏服务端程序\n为了逃避检测和延长存活时间，木马会在受害者的系统中自我启动，并采取各种隐蔽手段，如修改注册表、隐藏文件、进程名伪装、躲避反病毒软件检测等，以确保在系统重启后仍能继续运行且不被轻易发现。\n服务端和客户端建立连接\n一旦服务端在目标主机上激活并隐藏好自己，它就会尝试与攻击者控制的客户端建立连接。这可能通过直接连接到攻击者的服务器，或者采用更复杂的反弹端口技术，让受感染的机器主动向攻击者发起连接，从而绕过防火墙限制。\n在客户端进行远程控制\n连接建立后，攻击者就可以通过客户端发送指令至服务端，实现对目标计算机的全面控制。这包括但不限于文件管理、屏幕监控、键盘记录、摄像头和麦克风控制、执行系统命令、下载和上传文件、以及发起进一步的攻击等。\n植入技术 # 木马植入技术分为主动植入和被动植入两种。\n主动植入：攻击者直接、主动地将木马程序部署到目标计算机上。\n被动植入：攻击者设置好陷阱，等待受害者自行触发的过程。\n主动植入\n主动植入，一般需要通过某种方法获取目标主机的一定权限，然后由攻击者自己动手进行安装。\n按照目标系统是本地还是远程的区分，这种方法又有本地安装与远程安装之分。\n在一个系统植入木马，不仅需要将木马程序上传到目标系统，还需在目标系统运行木马程序;故主动植入不仅需要具有目标系统的写权限，还需要可执行权限。如果仅具有写权限，只能将木马程序上传但不能执行， 这种情况属于被动植入，因为木马仍需被动等待以某种 方式被执行\n主动植入 —— 本地安装\n直接在本地主机上进行木马安装。一些公用计算机或网吧计算机经常更换使用者，使得安装木马更容易奏效。\n主动植入 —— 远程安装\n通过常规攻击手段获得目标主机的一定权限后，将木马上传到目标主机上，并使其运行。\n远程安装 —— 利用系统自身漏洞植入：\n攻击者利用操作系统或应用程序中存在的未修复的安全漏洞（零日漏洞或已知但未广泛修复的漏洞），通过精心构造的数据包或代码，远程触发这些漏洞，以获得对目标系统的未授权访问。一旦获得访问权限，攻击者便可以上传木马程序，并执行必要的命令来启动木马。\n远程安装 —— 利用第三方软件漏洞植入：\n除了操作系统，许多计算机上安装的第三方应用（如办公软件、浏览器插件、PDF阅读器等）也可能存在安全漏洞。攻击者会密切关注这些软件的公告和漏洞数据库，利用未打补丁的漏洞，通过恶意网页、电子邮件附件或伪装的软件更新等方式，将木马与漏洞利用代码一并送达目标系统，进而植入木马。\n被动植入\n被动植入技术的特点在于，它更多依赖于目标用户的行为和疏忽，而不是直接的系统侵入。通过创造吸引用户交互的场景，木马得以在用户不知情的情况下被激活。因此，提高用户的安全意识、不随意点击不明链接或下载来源不明的文件，是防范此类木马植入的关键。\n网页浏览植入 攻击者通过在合法或被黑的网站上嵌入恶意代码（如JavaScript、恶意iframe或利用浏览器漏洞的exploit），当用户访问这些页面时，木马会自动下载并执行，或者诱导用户下载并安装伪装成安全更新、插件或有趣内容的恶意软件。\n程序捆绑或类型伪装 将木马与合法软件捆绑在一起，或将其伪装成用户可能感兴趣的文件类型（如文档、图片、视频等），当用户下载并打开这些文件时，木马随之激活。\n利用电子邮件植入 通过垃圾邮件或鱼叉式钓鱼邮件，将木马作为附件发送，或在邮件中嵌入带有恶意链接的文本或图片，诱导收件人点击下载或访问，从而植入木马。\n利用网络下载植入 在P2P分享网络、不受信任的下载站点或论坛上传带毒的热门软件、电影、游戏等资源，用户在下载和安装这些伪装成合法内容的文件时，木马被一并安装。\n利用即时通讯工具植入 通过即时通讯软件（如QQ、微信、Skype等）发送含有恶意链接的消息或文件，利用用户对联系人的信任来传播木马。\n利用移动存储设备植入 在U盘、移动硬盘等移动存储设备上预置自动运行脚本或伪装成重要文档的木马程序，当这些设备插入到计算机并被用户打开查看时，木马自动执行。\n自动加载技术 # 修改系统文件 木马替换或修改系统关键文件，如系统启动时会调用的exe或dll文件，使得木马代码随系统启动自动执行。\n修改系统注册表 通过修改Windows注册表中的自启动键值（如HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run或HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run），使得木马程序在每次系统启动时自动运行。\n添加系统服务 创建新的系统服务或将木马自身注册为现有服务的一部分，木马可以在系统后台以高权限级别自动启动。\n修改文件打开关联属性 通过修改文件类型关联，使得当用户打开特定类型的文件（如文本文件或图片）时，实际上激活木马程序。\n修改任务计划 在Windows的任务计划中设置定时任务，让木马在预定时间自动执行，或在用户登录时启动。\n修改组策略 通过修改组策略设置（Group Policy），在域环境中可以使木马在所有受策略影响的计算机上自动运行。\n修改启动文件夹 将木马快捷方式或可执行文件放置在Windows启动文件夹（如C:\\Users\\[用户名]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup），这样用户登录时木马就会自动启动。\n利用系统自动运行的程序 绑定或注入到Windows资源管理器、浏览器或其他经常自动启动的程序中，木马随着这些程序的启动而启动。\n替换系统DLL 替换系统动态链接库文件，当依赖这些DLL的程序运行时，实际上执行的是木马代码。\n隐藏技术 # 隐蔽性是木马的生命，是木马程序 与其它程序的重要区别。木马想要在目标主机上存活，必须注意隐藏自己，使自身不被主机合法用户所发现。对木马服务端的隐藏可以是伪隐藏，也可以是真隐藏。\n伪隐藏：程序的进程仍然存在，只不过是让它消失在进程列表里。\n真隐藏：让程序彻底的消失，不以一个进程或者服务的方式工作。\n设置窗口不可见（从任务栏隐藏） 通过编程技术使木马运行时不显示任何窗口或图标，从而在用户界面层面隐藏其存在。这是从任务栏中隐藏木马的基本手段，使得用户在日常操作中难以觉察到木马程序的运行。\n把木马程序注册为服务（从进程隐藏） 将木马伪装或附加到系统服务中，使其作为合法服务的一部分自动启动并在后台运行。这种技术不仅确保木马随系统启动，还能在进程列表中以合法服务的名义出现，避免引起怀疑。\n欺骗查看进程的函数（从进程隐藏） 利用API钩子、Hook技术或修改系统调用来干扰或篡改进程查看工具的结果，使木马进程在如任务管理器等工具中不可见，从而在进程列表中隐藏。\n使用可变的高端口（端口隐藏） 木马在与控制端通信时选择不常用的高端口，或频繁更改通信端口，以避开常规端口扫描和防火墙规则，实现端口隐藏。\n使用系统服务端口（端口隐藏） 更进一步的，木马可能利用系统默认开放的端口（如80, 443等）进行通信，因为这些端口通常不会被防火墙封锁，从而更难被识别和阻止，这也是端口隐藏技术的一种。\n替换系统驱动或系统DLL（真隐藏） 通过替换或注入到系统核心组件中，如驱动程序或动态链接库(DLL)，木马可以深入系统底层，实现真隐藏，极难被发现和移除。这种方式下，木马成为系统运行不可或缺的一部分，即使安全软件也很难识别其恶意行为。\n动态嵌入技术（真隐藏） 这是一种高级隐藏技术，木马不以固定的文件形式存在，而是动态地嵌入到其他进程的内存空间中运行，或利用内存映射文件等技术在系统中不留明显痕迹，进一步增加检测难度。\n连接技术 # 建立连接时，木马的服务端会在目标主机上打开一个默认的端口进行侦听(Listen)，如果有客户机向服务器端口提出连接请求(Connect Request)，服务器上的相关程序(木马服务器端)就会自动运行，并启动一个守护进程来应答客户机的各种请求\n端口侦听：木马服务端（位于被感染的目标主机上）首先会在系统中选定一个或几个端口（可能是固定端口，也可能是随机选择的高端口），并设置为侦听状态。这意味着服务端程序会持续监控这些端口，等待来自客户端的连接请求。选择端口时，木马可能会尝试使用不常见的端口号，以减少被防火墙或安全软件拦截的概率。\n连接请求：攻击者通过客户端程序（控制端），知道服务端的IP地址和开放的端口号后，会向这些地址和端口发出连接请求。这一步骤通常发生在攻击者想要与受控主机建立通信，下达指令或提取数据时。\n连接建立：当客户端的连接请求到达服务端所在主机并被正确识别后，服务端的木马程序会自动响应这一请求，建立起一个双向通信的连接。此时，服务端通常会启动一个守护进程（后台服务），专门负责处理来自客户端的命令和数据传输。\n数据交换与命令执行：一旦连接建立，攻击者就能通过客户端发送控制命令或下载/上传数据请求给服务端。服务端的守护进程接收到命令后，会按照命令执行相应的操作，如窃取文件、执行系统命令、修改系统设置、上传额外的恶意代码等。\n连接结束与隐藏：完成指定操作后，连接可能被木马程序自动关闭，以减少被发现的风险。同时，服务端程序会继续保持隐蔽状态，等待下一次连接请求的到来\n监控技术 # 木马在客户端端口和服务器端口之间建立连接后，木马客户端程序由该连接与木马服务器端程序联系，并对其进行远程控制：\n获取目标机器信息：木马能够收集并发送目标计算机的详细系统信息给攻击者，包括但不限于操作系统类型及版本、硬件配置、已安装软件列表、网络配置、系统用户名和密码散列等。这些信息有助于攻击者评估目标系统的价值，选择进一步的攻击路径，或利用特定漏洞。 记录用户事件：木马具有键盘记录功能，能够记录用户敲击的每一个按键，包括账号密码、聊天记录、电子邮件内容等敏感信息。此外，它还可以捕获屏幕截图、监控摄像头和麦克风，记录用户的视觉和音频活动，全方位监视用户的行为。这些数据被收集并定期发送给攻击者，用于窃取隐私信息或进行进一步的攻击计划。 远程操作：通过木马建立的连接，攻击者可以远程控制目标计算机执行各种操作，如文件管理（查看、上传、下载、修改、删除文件）、进程管理（启动、停止系统进程）、注册表编辑、服务控制、命令行执行等。这种能力让攻击者几乎能够像坐在目标计算机前一样操作，进行各种恶意活动，如植入更多恶意软件、盗取重要数据、操纵系统行为，甚至使用目标计算机作为跳板攻击其他系统。 木马实例 # Back Orifice 简介：Back Orifice是由黑客组织Cult of the Dead Cow (cDc)在1998年发布的，主要针对微软Windows操作系统。这个名字是对微软的系统管理工具“BackOffice”的戏谑。BO是一款功能强大的远程管理工具，但被设计用来作为非法入侵和控制他人计算机的木马。\n功能：BO允许攻击者远程控制被感染的计算机，包括但不限于文件管理、屏幕监控、键盘记录、摄像头控制、执行任意命令等。它通过隐蔽性强的手段，如修改注册表、自我复制和动态改变端口来躲避检测。\n影响：BO的发布引起了广泛的关注，因为它展示了个人计算机安全的脆弱性，促进了公众对个人电脑安全防护意识的提高，并促使软件开发商更加重视安全问题。\nSubSeven 简介：SubSeven是一款出现在2002年的远程管理工具/木马，它同样针对Windows平台，以其强大的功能和易用性在黑客社区中流行。\n功能：SubSeven提供了比Back Orifice更广泛的远程控制能力，包括但不限于文件管理、屏幕监控、键盘记录、摄像头和麦克风控制、系统信息收集、密码窃取、远程桌面控制等。它还支持通过IRC（互联网中继聊天）进行命令控制，增强了隐蔽性和控制的灵活性。\n影响：SubSeven因其高度的可定制性和用户友好的控制界面，成为了恶意用户广泛使用的工具，加剧了个人和企业电脑安全的威胁。它的出现促使了网络安全软件对木马检测能力的进一步提升。\n国产冰河 简介：冰河是国内开发的一款远程控制软件，最初设计为合法的远程管理工具，但因其强大的功能被滥用为木马，广泛流传于2000年代中期。\n功能：冰河提供了全面的远程控制能力，包括但不限于文件操作、进程管理、注册表操作、屏幕监控、键盘记录、摄像头和音频监控、远程命令执行等。它还采用了自定义加密通信和灵活的配置选项，提高了隐蔽性。\n影响：冰河因其在国内的广泛传播，对个人用户和企业的信息安全构成了严重威胁。它促使国内网络安全行业对本土化木马的研究与防护技术的发展，提升了对木马防御的重视程度，并促进了相关法律法规的制定和完善。\n木马的防御技术 # 木马的检测\n端口扫描和连接检查：木马为了与攻击者进行通信，往往会占用特定的端口。通过定期扫描系统开放的端口，尤其是那些不常见的或未授权的端口活动，可以发现潜在的木马活动。此外，检查系统中的网络连接，识别出与可疑IP地址或域名的异常连接，也是发现木马的有效方法。 检查系统进程：木马运行时会在系统中生成进程。通过任务管理器或专门的进程监控工具，检查系统中运行的所有进程，特别是那些未知的、异常命名或消耗大量资源的进程，可以揭示木马的存在。此外，分析进程的依赖关系和父进程，也能帮助追踪木马的源头。 检查ini文件、注册表和服务：木马为了实现自启动，常常会修改ini文件（旧版Windows系统中）、注册表键值或创建系统服务。通过细致检查这些位置的改动，特别是新添加的启动项、修改的键值或异常的服务，可以帮助识别木马的自启动机制和位置。 监视网络通讯：通过网络监控软件或防火墙日志，分析进出的网络流量和数据包，可以发现木马的通信模式。特别注意那些加密的、异常的或频繁的对外连接，它们可能是木马与控制服务器的通信。网络监控还能揭示木马尝试外传数据的企图，如个人信息或敏感文件的泄露。 木马的清除与善后\n知道了木马的加载位置后，首先要做的是将木马登记项删除，使得木马无法在开机时启动\n有些木马进程会监视注册表，一旦注册表项被删除， 它立即恢复回来。因此，在删除前需停止木马进程，然后根据木马登记的目录将相应的木马程序删除\n随着木马实现技术不断进步，很多木马带有自我保护机制，木马类型不断变化，因此，不同木马需要有针对性的清除方法\n对于普通用户来说，最好借助专业杀毒软件或木马清除软件来清除木马。安装优秀的杀病毒和防火墙软件并定期升级，不失为一种安全防范的有效手段\n木马的防范\n及时修补漏洞，安装补丁：操作系统、浏览器和其他常用软件经常会发现安全漏洞，这些漏洞往往是木马入侵的通道。因此，定期检查并安装软件更新和安全补丁至关重要。这能有效封堵安全漏洞，减少被木马利用的风险。 运行实时监控程序：安装并启用一款可靠的安全软件，如防病毒软件或互联网安全套件，这些软件通常包含实时监控功能，能够持续扫描系统，检测并阻止木马等恶意软件的活动。确保安全软件保持最新，以便能够防御最新的威胁。 培养风险意识，不使用来历不明的软件：用户应该养成良好的网络卫生习惯，避免下载和安装未经验证的软件，特别是来自不可信网站、邮件附件或P2P网络的文件。只从官方网站或经过认证的平台获取软件，并确认下载链接的真实性。 即时发现，即时清除：一旦发现系统有异常行为，如无故变慢、出现未知进程、网络流量异常增加等，应立即使用安全软件进行全面扫描，并按照提示清除发现的威胁。对于难以清除的顽固木马，可能需要进入安全模式或使用专业的反木马工具进行处理。 木马的发展趋势 # 跨平台：早期木马往往针对特定操作系统或平台设计，但现在越来越多的木马采用跨平台技术，能够感染Windows、macOS、Linux、Android、iOS等多种操作系统，甚至是物联网设备，极大地扩展了其潜在的攻击范围。 模块化设计：模块化设计使得木马更加灵活和可扩展。木马被分解成多个功能模块，如信息窃取、远程控制、传播、自我隐藏等，每个模块可以独立更新或替换，使得木马能够快速适应新的攻击策略或绕过最新的安全防御措施。 无连接木马：传统的木马需要与C\u0026amp;C（命令与控制）服务器建立明确的连接来接收指令，而无连接木马则减少或不依赖直接的网络连接，采用更隐蔽的通信方式，如利用社交媒体、合法的Web服务或P2P网络作为指令传递的渠道，以减少被发现的风险。 主动植入：木马的植入技术从被动等待用户操作激活转向主动攻击，利用自动化工具和脚本、零日漏洞利用、供应链攻击等方法直接将木马植入目标系统，降低了对用户交互的依赖，提高了成功率。 木马与病毒的融合：以往木马和病毒被视为不同类型的恶意软件，但现在的趋势是两者融合，形成复合型威胁。木马可能携带病毒功能，如自我复制和传播机制，或者病毒携带木马的控制模块，使得单一恶意软件具备多重攻击能力，更难于清除和防御。 ","date":"2024/6/8","externalUrl":null,"permalink":"/blogs/trojan/","section":"Blogs","summary":"软件与系统安全笔记(8) - 木马","title":"软件与系统安全笔记(8) - 木马","type":"blogs"},{"content":"软件与系统安全笔记(5) - 代码混淆\n代码混淆 # 代码混淆（Obfuscation）是一种在软件保护领域广泛应用的技术，其主要目的是为了提高程序代码的阅读和理解难度，从而阻碍逆向工程(reverse engineering)的进行。这一技术通过修改源代码、字节码或二进制代码，使代码在功能上保持不变，但其结构、变量名、函数名等被改写得难以理解，增加了非法分析者逆向分析软件以获取其内部逻辑、算法或敏感信息的难度。\n混淆的主要技术手段包括但不限于：\n数据混淆：对常量、字符串等数据进行加密或编码，运行时再解密使用，使得静态分析中难以直接看到原始数据。 控制流混淆：通过插入无意义的跳转、条件分支等，改变代码的正常执行流程，但确保最终结果不变，这大大增加了分析的复杂度。 模型与层次\n输入与输出程序的语义等价：混淆过程必须保证处理后的程序在功能上与原程序完全一致，只是表现形式不同，这是混淆的基本原则。 混淆的层次： 源代码级混淆：直接对高级编程语言的源代码进行修改。 汇编/二进制级混淆：在编译后的机器代码层面进行操作，这通常涉及到更底层的指令重写和优化。 中间代码/字节码级混淆：对于像Java、.NET这类平台，可以在其字节码或中间代码（如Java bytecode, MSIL）上进行混淆，这是较为常见的混淆方式，因为这类代码比源代码更接近机器码，同时仍保留了一定程度的平台独立性和可操作性。 完美混淆器 # 对于一个概率算法O，完美混淆器需要满足下面三个条件：\n功能性（Functionality）: 这意味着混淆后的程序O(P)必须保持与原程序P完全相同的功能。也就是说，对于任何可能的输入x，O(P)(x)和P(x)的结果必须一致。这一条件保证了混淆过程不改变程序的行为，只是改变了其表现形式。 多项式减速（Polynomial Slowdown）: 混淆后的程序在最坏情况下的运行时间（时间和空间复杂度）相比原程序最多只能是多项式级别的增长。这是为了确保混淆虽然增加了程序的复杂度，但仍然保持了实用性和效率。 虚拟黑盒（Virtual Black-Box, VBB）属性: 这是最关键也是最具挑战性的条件。它要求即使一个具有强大计算能力的攻击者，拥有混淆程序O(P)的完整源代码或二进制代码，并且能够在多项式时间内执行任意复杂的计算，也无法从O(P)中学到关于原程序P的任何额外信息，除了通过反复执行O(P)并观察输出（即所谓的黑盒测试）所能获取的信息。简而言之，混淆后的程序对于攻击者来说就像一个黑盒，尽管他们可以看到盒子内部的每一个细节，但是仍无法理解其工作原理或逆推出原始程序的结构。 数据混淆 # 常量展开 # 假设程序在某处使用了一个常量值，可以利用一个计算过程代替这个常量值，而这个计算过程的结果就是这个常量值\n比如：x = 4 可以混淆成 x = 2 + 2\n数据编码 # 数据编码是将原始数据转换成不易识别的编码数据来增加逆向工程的难度。\n假设有一个编码函数f(x)：\n混淆：将x0 -\u0026gt; f(x0） 解混淆：将f(x0) -\u0026gt; x0。 编码函数f必须满足：\n给定f(x)，无法推测出x 给定x和f(x)，无法推测出f 多项式编码\n多项式编码通过将数据映射到多项式的值上来实现混淆。\nf(x) = a_nx^n + \u0026hellip; + a_1x + a_0。\n这种方法的优势在于，即使攻击者知道多个 (x,f(x)) 对，直接从多项式系数逆推出原始数据或多项式本身也相对困难，尤其是当多项式的阶数较高时。\n剩余数编码\n剩余数编码基于模运算，先选择几个互质的模m1, m2, \u0026hellip; , mk，然后将原始数据x对这些模分别取余得到 y1 = x mod m1, y2 = x mod m2, \u0026hellip; yk = x mod mk。解码的时候，需要通过中国剩余定理或其他算法利用y1,\u0026hellip;yk和m1,\u0026hellip;mk求出x。这种方法增加了逆向分析的复杂度，因为攻击者需要处理多个模运算的关系，而非单一的直接转换。\n同态编码\n一般的编码方案在运行前需要动态解码，会引入额外的计算开销，并可能暴露解码逻辑。而同态编码允许直接利用编码后的数据进行计算，而无需先解码再运算。\n对于两个群G,H，如果存在一个映射f: G -\u0026gt; H，且对于两个元素x, y属于G，那么f(x),f(y)属于H，那么f如果是个同态映射，就意味着f(x +g y) = f(x) +h f(y)，其中+g是群G中的运算，+h是群H中的运算。\n举个例子：\nx1和x2，混淆后分别为f(x1)和f(x2)，运行时如果要计算x1*x2，需要先把f(x1)-\u0026gt;x1，f(x2)-\u0026gt;x2，再进行运算。而同态编码允许运行的时候直接计算f(x1) * f(x2) = f(x1 * x2) -\u0026gt; x1 * x2。种性质使得可以在保护隐私的同时处理数据，特别适用于云计算和数据安全领域。\n将同态的概念应用于代码混淆或数据保护时，我们可以构建这样的系统：源代码或数据在某个“未编码域”（原始的、易理解的形式）中定义，对应于代数结构G；通过一个同态映射f，这些源代码或数据被转换到“编码域”（混淆的、难以解读的形式），对应于另一个代数结构H。关键在于，这个映射不仅要保证混淆后的数据在功能上等价于原数据，而且要在H中定义一套运算规则，使得对编码后数据的操作结果，经过逆映射后，等同于原数据在G中直接操作的结果。\n全同态加密就是能进行任意运算，不管加法、乘法乃至更复杂的操作，都满足上面的定义。\n基于模式的混淆 # 基于模式的混淆就是将简单的、容易理解的指令替换为功能等价但更为复杂的指令。\n举个例子：\n-x -\u0026gt; ~x+1\n在计算机中，对一个数取负数，等价于对这个数取反并加1。\n比如整数1，二进制为0001，对0001进行取反并+1后就是1111。而1111代表的就是-1。\n控制流混淆 # 二进制静态分析对控制流的假定 # CALL指令只用于函数调用, 且调用目标即函数的起始地址\n绝大多数函数调用会返回, 且返回到CALL指令的后一条指令的位 置; RET和RETN代表函数边界\n遇到条件跳转时, 假定: 分支两侧均可能被执行; 分支两侧均为代码而非数据\n容易确定间接跳转的目标地址\n只有switch结构能够生成间接跳转; 只有对函数指针的调用能够 生成间接调用\n所有控制转移目标地址都是代码而非数据\n异常以一种可预测的方式使用\n控制流混淆旨在通过改变程序的正常控制流程，使得攻击者难以理解和分析程序的行为。\n打破CALL指令的直接关联: 通常，CALL指令被假定为仅用于函数调用，并且其目标是函数的起始地址。混淆技术可以插入无意义的CALL指令到非函数起始位置，或者使用自定义的跳转指令代替标准的CALL，使得分析者难以区分真实函数调用与混淆指令。\n扰乱函数返回流: 通过在函数返回点插入额外的跳转指令，或者使用非标准的返回机制（如返回到非CALL之后的位置），混淆技术可以使程序的返回流程变得难以追踪。此外，还可以使用“花指令”（无意义的指令序列）来混淆函数的退出路径。\n复杂化条件跳转: 改变条件跳转的逻辑，引入看似无关的条件检查，或者使用复杂的计算来决定跳转目标，使分析者难以判断分支行为。同时，也可以将数据区域伪装成可执行代码，让分析工具误以为数据也是潜在的控制流部分。\n间接跳转目标的隐蔽化: 利用动态计算的跳转表、随机化或加密跳转目标地址，使得间接跳转的目的地在静态分析时难以确定。这包括对switch-case结构的混淆和对函数指针调用的隐藏，使得它们的目标不再是显而易见的。\n混淆代码与数据边界: 将代码片段嵌入到数据区域，或将数据块布置得像可执行代码，混淆分析者对内存区域的直观判断。这样，即使是间接跳转，也可能指向看似数据的区域，实际上却执行了代码。\n异常处理的混淆: 通过异常处理机制插入混淆代码，或者将正常的控制流逻辑伪装成异常处理路径，可以进一步模糊程序的实际执行流程。异常的触发和处理方式变得不透明，增加了逆向工程的难度。\n组合使用函数内联与外联 # 函数内联：将函数的代码直接复制到调用的地方。\n比如：\nint add(x, y){ return x + y; } int main(){ int x = 1; int y = 2; int z = add(x, y); return 0; } ### 函数内联 ### ### 直接将add函数的代码块复制到main函数里，变为：### int main(){ int x = 1; int y = 2; int z = x + y; return 0;\t} 函数外联：与函数内联相反，将一部分代码抽离出来单独写个函数，然后将代码块的部分替换为函数的调用。\n通过跳转破坏局部性 # 通过跳转的思想是打乱代码的自然执行顺序。\n在未经混淆的在未经混淆的程序中，代码通常按照逻辑上的连续性和相关性组织，形成了良好的局部性，便于人类理解和分析。控制流图（CFG，Control Flow Graph）中的基本块（Basic Block）通常紧密相连，代表了直接的执行序列。通过在基本块中不必要地插入无条件跳转（Jump）或goto语句，可以打破这种自然的执行流，使得相邻的语句在执行时可能相隔甚远，或者使得代码执行路径变得错综复杂。\n比如，原本连续的几行代码：\nA; // 执行语句A B; // 执行语句B C; // 执行语句C D; // 执行语句D E; // 执行语句E F; // 执行语句F 在经过跳转混淆后可能会变成：\nA; // 执行语句A jump to D; B; // 执行语句B jump to E; C; // 执行语句C jump to F; D: jump to B; E: jump to C; F: // 正常继续执行后续代码 这种混淆方法极大地混淆了代码的直观阅读，使得分析者难以直接通过阅读代码逻辑来理解程序的工作方式。\n不透明谓词 # 不透明谓词就是一种特殊的条件判断语句，但是这个条件判断语句的值只有混淆者知道，对于攻击者而言很难判断这个条件判断语句的值。\n不透明谓词的分类\nPT（Always True）: 这类不透明谓词在编译或混淆阶段已知其值永远为真。将其作为分支条件插入代码中，不会实际改变执行路径，但对于不知情的分析者来说，它会掩盖真实控制流程，让其看起来仿佛有额外的分支选择。 PF（Always False）: 相对于PT，PF类型的不透明谓词在混淆时确定其值总是假。同样，它也被用作条件判断，可以引入看似可能影响控制流但实际上恒不被执行的代码路径。 P?（Indeterminate）: 这类不透明谓词的值在混淆时可能为真也可能为假，但其确定性对于外部分析者来说难以判断。利用P?可以创建更加复杂的混淆效果，使得分析者难以区分哪些分支是真正有意义的，只有混淆者才能知道哪些分支才真正有意义。 不透明谓词的应用\n增加伪分支：在程序的关键路径中插入基于不透明谓词的条件分支，可以创建出额外的控制流路径，这些路径要么永远不被执行，要么其执行与否对程序逻辑没有实际影响。这种做法能够显著增加控制流图（CFG）的复杂度，使逆向分析更加困难。 混淆条件逻辑：在实际的逻辑判断中嵌入不透明谓词，即使这些谓词的值对结果没有影响。例如，一个简单的布尔逻辑if (condition \u0026amp;\u0026amp; PT)，其中condition是真实逻辑判断，而PT是始终为真的不透明谓词，这种组合使得分析者难以分辨condition的真实作用。 举几个例子：\n如果我们想执行A，可以将PT放到if的判断里，由于PT的值恒true，运行的时候只会执行A，不可能执行B。但是对于攻击者而言，他无法判断PT的值，所以他会觉得B也是有可能执行的。\nif (PT) { A; // 执行A } else { B; // 执行B } PF的值恒为false，所以不可能执行C，这个分支毫无意义，但是对于攻击者而言，他无法判断PF的值，所以会消耗成本去分析这个假分支。\nif (PF) { C; // 执行C } 插入无效代码 # 死代码（Dead Code）插入\n目的：侧重于数据混淆，通过修改或操作不会影响程序最终结果的“死”变量或寄存器，使得分析者难以区分哪些数据操作是真正有用的。\n示例：\nint f() { int x, y; x = 1; // 下面的代码是死代码，因为x的值在被使用前会被重新赋值 x = x + 2; // y从未被使用，属于死代码 y = 2; // 在此之前，x的初始值未被使用，是\u0026#34;死\u0026#34;的，但此处赋值后变为\u0026#34;活\u0026#34; x = 3; return x; } 垃圾代码（Junk Code）插入\n目的：侧重于控制流混淆，通过在永远不会执行到的程序分支中插入大量无用代码，使得控制流显得更加复杂，增加分析难度。\n实现：混淆器识别出程序中的无用分支（例如，基于不透明谓词的总是为真或为假的分支），并在这些分支内填充大量看似执行逻辑但实际无效的代码。\n注意：与死代码相比，垃圾代码强调的是其位于不可达的代码路径上，因此即便其操作了“活”的变量或寄存器，也不会影响程序的正常执行。\n控制流间接化 # 控制流间接化是混淆技术中一种高级策略，它通过动态计算分支和调用目标地址，以及模拟处理器指令，使得控制流分析更加困难。\nJMP指令间接化\n将直接跳转指令（如JMP \u0026lt;目标地址\u0026gt;）间接化，可以使用以下模式：\nPUSH \u0026lt;目标地址\u0026gt; RET 这种间接跳转方式通过将目标地址压栈，然后执行RET指令（相当于弹出栈顶内容至EIP寄存器），实现了跳转。这种方式使得静态分析时难以直接确定跳转目标，因为目标地址是在运行时计算和压栈的。\nCALL指令间接化及其扩展\n对于CALL \u0026lt;目标地址\u0026gt;指令，可以通过以下模式进行间接化，并在目标地址处进行相应处理以保持控制流的完整性：\n地址x: CALL \u0026lt;目标地址\u0026gt; 地址x+5: \u0026lt;垃圾代码\u0026gt; ; 可选，进一步混淆 ... 目标地址: ADD ESP, 4 ; 清除CALL压入的返回地址 ; 接下来是实际的函数代码 此间接化方式同样隐藏了直接调用关系，CALL指令通过栈传递目标地址，到达目标函数后首先清理栈顶的返回地址（通常CALL指令会自动压入返回地址到栈上），然后继续执行函数代码。\n更改返回地址与模拟返回流程\n在某些混淆场景中，为了进一步混淆控制流，会修改函数的返回流程，例如：\nCALL \u0026lt;函数A\u0026gt; 原始返回地址: \u0026lt;垃圾代码\u0026gt; ; 可能包含误导性指令 ... 实际返回地址: NOP ; 或其他不影响EIP移动的指令 ... 在函数A结束时，为了返回到正确的地址，可能需要特殊处理：\n函数A起始地址: ADD [ESP], 9 ; 假设ESP当前指向返回地址上方9字节的位置，此操作实际上是跳过了垃圾代码 RET 这种技巧通过修改栈上的返回地址（通常是向上或向下调整栈指针），使得执行流绕过混淆插入的“垃圾代码”部分，直接跳转到实际的返回点，从而保证程序的正确执行，同时也极大地混淆了分析者对控制流的理解。\n通过这些间接化和模拟技术，控制流混淆极大地增加了逆向工程的难度，不仅使得静态分析工具难以准确识别代码结构，也使得手动分析更加复杂和耗时。不过，这类混淆手段需要仔细设计以避免对性能造成过大影响，并确保程序的正确性。\n控制流图扁平化 # 将程序原有的多层嵌套控制结构（如条件分支、循环等）打散并重新组织，通过一个中心分发器来控制程序的执行流程。将本来的代码分成几个基本的块，然后通过中心分发器来连接这些基本块；基本块之间的关系被隐藏在基本块之中。\n举个例子：\nint a,b; a=1; b=2; while(a\u0026lt;10){ b=a+b; if(b\u0026gt;10) b--; a++; } use(b); 画出上面这个控制流图，为： 通过switch这个中心分发器，我们可以将上面的程序更改为：\nint a, b, swVar; start: switch(swVar){ case 1: a = 1; b = 2; swVar = 2; goto start; case 2: if (a \u0026lt; 10){ swVar = 3; } else { swVar = 6; } goto start; case 3: b = b + a; if (b \u0026gt; 10){ swVar = 5; } else { swVar = 4; } goto start; case 4: b --; swVar = 5; goto start; case 5: a ++; swVar = 2; goto start; case 6: use(b); } 控制流图为：\n","date":"2024/6/5","externalUrl":null,"permalink":"/blogs/codeobfuscation/","section":"Blogs","summary":"软件与系统安全笔记(5) - 代码混淆","title":"软件与系统安全笔记(5) - 代码混淆","type":"blogs"},{"content":"生日：2003.11.13\n现就读于西安电子科技大学网安实验班大三\n这个博客的目的是记录我的学习历程\n","date":"2024/5/18","externalUrl":null,"permalink":"/about/","section":"Enly","summary":"生日：2003.11.13","title":"About","type":"page"},{"content":"","date":"2023/11/13","externalUrl":null,"permalink":"/tags/conda/","section":"Tags","summary":"","title":"Conda","type":"tags"},{"content":"macOS安装及卸载Miniconda教程\n1 安装 # 查看你要安装的版本 打开 Miniconda版本仓库，复制你要安装版本的名字，注意是.sh后缀的文件名。\n不要点击链接下载！！！ 只复制文件的名字，例如Miniconda3-py39_24.4.0-0-MacOSX-arm64.sh。 快速命令行安装 打开终端执行以下命令：\nmkdir -p ~/miniconda3 curl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh -o ~/miniconda3/miniconda.sh bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3 rm -rf ~/miniconda3/miniconda.sh 第二行命令中的Miniconda3-latest-MacOSX-arm64.sh适用于苹果M芯片的最新Miniconda版本。如果你是Intel芯片，或者想安装其他版本，请将你在步骤1)中复制的版本名替换上面第二行命令中的Miniconda3-latest-MacOSX-arm64.sh 安装后，初始化新安装的Miniconda，打开终端执行以下命令：\n~/miniconda3/bin/conda init bash ~/miniconda3/bin/conda init zsh 2 conda配置国内镜像源 # 推荐配置中科大镜像源，其他镜像源可以自行搜索配置。\n打开命令行执行以下命令：\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ conda config --set show_channel_urls yes 显示现有安装源：\nconda config --show channels 恢复默认源：\nconda config --remove-key channels 移除某个源：\nconda config --remove channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ 3 conda常用命令 # 功能 命令 获取版本号 conda -v 获取帮助 conda -h 创建环境 conda create -n environment_name 创建指定python版本下包含某些包的环境 conda create -n environment_name python= 3.7 numpy scipy 进入环境 conda activate environment_name 退出环境 conda deactivate 删除环境 conda remove -n environment_name - -all 列出所有环境 conda env list 将旧环境复制到新环境 conda create - -name new_env_name - -clone old_env_name 安装包 conda instal package_name 查看当前环境包列表 conda list 查看指定环境包列表 conda list -n environment_name 查看conda源中包的信息 conda search package_name 更新包 conda update package_name 删除包 conda remove package_name 清理无用的安装包 conda clean -p 清理tar包 conda clean -t 清理所有安装包及cache conda clean -y - -all 4 卸载 # 使用Anaconda-Clean包删除所有与conda相关的文件和目录： conda activate environment_name conda install anaconda-clean anaconda-clean 删除整个目录 rm -rf ~/miniconda3 删除PATH环境变量中的conda路径 将# \u0026raquo;\u0026gt; conda initialize \u0026raquo;\u0026gt;和# \u0026laquo;\u0026lt; conda initialize \u0026laquo;\u0026lt;之间的所有内容删除 vim ~/.bash_profile 进入vim后按i进入编辑模式，删除完后按:wq!进行保存并退出。保存后执行下面的命令。 source ~/.bash_profile 同理，对zsh也执行上述操作。\nvim ~/.zshrc source ~/.zshrc 删除配置文件 rm -rf ~/.condarc ","date":"2023/11/13","externalUrl":null,"permalink":"/blogs/condainstall/","section":"Blogs","summary":"macOS安装及卸载Miniconda教程","title":"macOS安装及卸载Miniconda教程","type":"blogs"},{"content":"动手学深度学习 - 《 Dive into Deep Learning 》学习笔记\n","date":"2023/7/22","externalUrl":null,"permalink":"/blogs/diveintodeeplearning/","section":"Blogs","summary":"动手学深度学习 - 《 Dive into Deep Learning 》学习笔记","title":"动手学深度学习笔记","type":"blogs"},{"content":"","date":"2023/7/22","externalUrl":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"机器学习","type":"tags"},{"content":"","date":"2023/7/22","externalUrl":null,"permalink":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"深度学习","type":"tags"},{"content":"西瓜书 - 《 机器学习 》学习笔记 - 9-16章\n第9章 聚类 # 第10章 降维与度量学习 # 第11章 特征选择与稀疏学习 # 第12章 计算学习理论 # 第13章 半监督学习 # 第14章 概率图模型 # 第15章规则学习 # 第16章 强化学习 # ","date":"2023/4/23","externalUrl":null,"permalink":"/blogs/watermelonnote2/","section":"Blogs","summary":"西瓜书 - 《 机器学习 》学习笔记 - 9-16章","title":"西瓜书笔记(下)","type":"blogs"},{"content":"西瓜书 - 《 机器学习 》 学习笔记 - 1-8章\n第1章 绪论 # 第2章 模型评估与选择 # 第3章 线性模型 # 第4章 决策树 # 第5章 神经网络 # 第6章 支持向量机 # 第7章 贝叶斯分类 # 第8章 集成学习 # ","date":"2023/4/12","externalUrl":null,"permalink":"/blogs/watermelonnote1/","section":"Blogs","summary":"西瓜书 - 《 机器学习 》 学习笔记 - 1-8章","title":"西瓜书笔记(上)","type":"blogs"},{"content":"","date":"2022/11/21","externalUrl":null,"permalink":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"Tags","summary":"","title":"编译原理","type":"tags"},{"content":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 绘图器\n报告及代码链接：\nZhanYirui/FGLCompiler C\u0026#43;\u0026#43; 1 0 第三部分:绘图器 (完整代码在最后)\n测试文本:\nOrigin Is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 ​ 绘图器的代码是在第二部分语法分析器的基础上改编来的。\n首先我们把第二部分语法分析器Parsers类里面的Parser()、Program()\u0026hellip;、ForStatement()成员函数里面的\u0026quot;enter in\u0026quot;、\u0026ldquo;exit from\u0026quot;以及\u0026quot;matchtoken\u0026quot;语句删除。\n在Parsers类的OriginStatement()、ScaleStatement()、RotStatement()、ForStatement()函数里面，我们得到了很多棵表达式树，在语法分析器里面我们是将它们用OutExprNode()函数先序遍历打印出来的，但是在绘图器里面，我们不需要把表达式树打印出来，我们需要表达式树它最终求出来的值，所以我们要把OutExprNode()函数改成GetExpValue()函数，两个函数很相似都是利用递归，我在语法分析器里已经分析过了，下面直接给出GetExpValue()函数的代码:\ndouble GetExpValue(struct ExprNode* Tree) { if (Tree == NULL) return 0.0; switch (Tree-\u0026gt;OpCode) { case PLUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) + GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MINUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) - GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MUL: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) * GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case DIV: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) / GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case POWER: return pow(GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left), GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right)); case FUNC: return Tree-\u0026gt;Content.CaseFunc.MathFuncPtr(GetExpValue(Tree-\u0026gt;Content.CaseFunc.Child)); case CONST_ID: return Tree-\u0026gt;Content.CaseConst; case T: return *(Tree-\u0026gt;Content.CaseParmPtr); default: return 0.0; } } 我们将语法分析器中的OutExprNode()函数换成GetExpValue()函数，这时候我们就能得到原点平移的横纵坐标的值origin_x和origin_y，横纵坐标放缩的值scale_x和scale_y，旋转的弧度值rot_ang，绘图时候参数T的起始值start、结束值end和步长step，但是现在注意了，FOR语句后面括号里面那两棵表达式树(struct ExprNode*)for_xptr,for_yptr里面带有参数T，所以我们不能直接在ForStatement()函数里面将这两棵表达式树的值求出来，而且根据要求，文件中Origin、Scale、Rot语句只影响它们后面的For语句，而且一个文件里面可以有多个FOR语句，所以我们在获得FOR语句括号里的两棵表达式树之后，我们要拿七个double容器将origin_x,origin_y,scale_x,scale_y,start,end,step装起来，拿两个struct ExprNode*容器将for_xptr和for_yptr装起来，这个时候这九个容器同一个下标里的内容就可以画出一个图形，ForStatement()函数改编后如下:\nvoid ForStatement(){ MatchToken(FOR); MatchToken(T); MatchToken(FROM); start_ptr = Expression(); start = GetExpValue(start_ptr); MatchToken(TO); end_ptr = Expression(); end = GetExpValue(end_ptr); MatchToken(STEP); step_ptr = Expression(); step = GetExpValue(step_ptr); MatchToken(DRAW); MatchToken(L_BRACKET); for_xptr = Expression(); For_X.push_back(for_xptr); MatchToken(COMMA); for_yptr = Expression(); For_Y.push_back(for_yptr); Origin_X.push_back(origin_x); Origin_Y.push_back(origin_y); Scale_X.push_back(scale_x); Scale_Y.push_back(scale_y); Rot_ang.push_back(rot_ang); Start.push_back(start); End.push_back(end); Step.push_back(step); MatchToken(R_BRACKET); } 现在我们有九个容器，每个容器都装着图形的一个参数，下一步就是来画图了。\n我利用的是EasyX，Clion下EasyX的配置教程参考: (8条消息) 在Clion中使用EasyX配置_Shine.Zhang的博客-CSDN博客\n只要能用\u0026lt;graphics.h\u0026gt;库就行了，各位自己去寻找导入方法吧。\n接下来先写一个画单个点的函数void DrawXY(double for_x, double for_y, double origin_x, double origin_y, double scale_x, double scale_y, double rot_ang)，传进去的是点的坐标、横纵坐标平移值、横纵坐标拉伸值以及旋转弧度值，代码如下:\nvoid DrawXY(double for_x, double for_y, double origin_x,double origin_y,double scale_x,double scale_y,double rot_ang){ double tempx, tempy; for_x *= scale_x; for_y *= scale_y; tempx = for_x; tempy = for_y; for_x = tempx * cos(rot_ang) + tempy * sin(rot_ang); for_y = tempy * cos(rot_ang) - tempx * sin(rot_ang); for_x += origin_x; for_y += origin_y; putpixel(for_x,for_y,RGB(255,255,255)); } 上面这段代码先将横纵坐标分别乘横纵坐标拉伸值，再根据旋转的规则:旋转后横坐标=旋转前横坐标cos(旋转弧度)+旋转前纵坐标sin(旋转弧度)，旋转后纵坐标=旋转前纵坐标cos(旋转弧度)-旋转前横坐标sin(旋转弧度) 将旋转后的横纵坐标求出来，再分别加上横纵坐标平移值，就得到了操作后的点，最后用putpixel()函数将点画出来。\n接下来我们就要通过循环令Parameter变量不断变化从而画出所有点，DrawTotalXY函数如下:\nvoid DrawTotalXY(Parsers P, double Origin_X,double Origin_Y,double Scale_X,double Scale_Y,double Rot_ang, double Start, double End, double Step, struct ExprNode* For_X, struct ExprNode* For_Y) { double x,y; Parameter = Start; if (Step \u0026gt; 0) { while (Parameter \u0026lt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); Parameter += Step; } } else if(Step \u0026lt; 0){ while (Parameter \u0026gt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); Parameter += Step; } } } 最后在main函数里面，我们通过下标从九个容器中取参数传到DrawTotalX函数里面画出所有的图像即可，完整代码如下，绘图器部分就完成了，这次上机也完成了。\n绘图器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdarg\u0026gt; #include \u0026lt;graphics.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } typedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; vector\u0026lt;double\u0026gt; Origin_X; vector\u0026lt;double\u0026gt; Origin_Y; vector\u0026lt;double\u0026gt; Scale_X; vector\u0026lt;double\u0026gt; Scale_Y; vector\u0026lt;double\u0026gt; Rot_ang; vector\u0026lt;double\u0026gt; Start; vector\u0026lt;double\u0026gt; End; vector\u0026lt;double\u0026gt; Step; vector\u0026lt;struct ExprNode*\u0026gt; For_X; vector\u0026lt;struct ExprNode*\u0026gt; For_Y; class Parsers{ public: Parsers(){LoadFileTokens();} struct ExprNode *origin_xptr, *origin_yptr, *scale_xptr, *scale_yptr, *rot_ptr, *start_ptr, *end_ptr, *step_ptr, *for_xptr, *for_yptr; double Parameter = 0, origin_x = 0, origin_y = 0, scale_x = 1, scale_y = 1, rot_ang = 0, start, end, step; static int cnt; Tokens TempToken; struct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } double GetExpValue(struct ExprNode* Tree) { if (Tree == NULL) return 0.0; switch (Tree-\u0026gt;OpCode) { case PLUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) + GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MINUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) - GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MUL: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) * GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case DIV: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) / GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case POWER: return pow(GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left), GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right)); case FUNC: return Tree-\u0026gt;Content.CaseFunc.MathFuncPtr(GetExpValue(Tree-\u0026gt;Content.CaseFunc.Child)); case CONST_ID: return Tree-\u0026gt;Content.CaseConst; case T: return *(Tree-\u0026gt;Content.CaseParmPtr); default: return 0.0; } } void FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Error Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Unexpected Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } void Parser(){ FetchToken(); Program(); } void Program(){ while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); } } void Statement(){ if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); } void OriginStatement(){ MatchToken(ORIGIN); MatchToken(IS); MatchToken(L_BRACKET); origin_xptr = Expression(); origin_x = GetExpValue(origin_xptr); MatchToken(COMMA); origin_yptr = Expression(); origin_y = GetExpValue(origin_yptr); MatchToken(R_BRACKET); } void RotStatement(){ MatchToken(ROT); MatchToken(IS); rot_ptr = Expression(); rot_ang = GetExpValue(rot_ptr); } void ScaleStatement(){ MatchToken(SCALE); MatchToken(IS); MatchToken(L_BRACKET); scale_xptr = Expression(); scale_x = GetExpValue(scale_xptr); MatchToken(COMMA); scale_yptr = Expression(); scale_y = GetExpValue(scale_yptr); MatchToken(R_BRACKET); } void ForStatement(){ MatchToken(FOR); MatchToken(T); MatchToken(FROM); start_ptr = Expression(); start = GetExpValue(start_ptr); MatchToken(TO); end_ptr = Expression(); end = GetExpValue(end_ptr); MatchToken(STEP); step_ptr = Expression(); step = GetExpValue(step_ptr); MatchToken(DRAW); MatchToken(L_BRACKET); for_xptr = Expression(); For_X.push_back(for_xptr); MatchToken(COMMA); for_yptr = Expression(); For_Y.push_back(for_yptr); Origin_X.push_back(origin_x); Origin_Y.push_back(origin_y); Scale_X.push_back(scale_x); Scale_Y.push_back(scale_y); Rot_ang.push_back(rot_ang); MatchToken(R_BRACKET); } struct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Term(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Factor(); while (TempToken.type == MUL || TempToken.type == DIV) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Factor(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Factor(){ struct ExprNode *left, *right; if(TempToken.type == PLUS){ MatchToken(PLUS); right = Factor(); left = NULL; right = MakeExprNode(PLUS,left,right); } else if(TempToken.type == MINUS){ MatchToken(MINUS); right = Factor(); left = MakeExprNode(CONST_ID,0.0); right = MakeExprNode(MINUS,left,right); } else right = Component(); return right; } struct ExprNode* Component(){ struct ExprNode *left, *right; left = Atom(); if(TempToken.type == POWER){ MatchToken(POWER); right = Component(); left = MakeExprNode(POWER,left,right); } return left; } struct ExprNode* Atom(){ struct ExprNode *address, *tmp; double const_value; FuncPtr funcPtr_value; if(TempToken.type == CONST_ID){ const_value = TempToken.value; MatchToken(CONST_ID); address = MakeExprNode(CONST_ID,const_value); } else if(TempToken.type == T){ MatchToken(T); address = MakeExprNode(T); } else if(TempToken.type == FUNC){ funcPtr_value = TempToken.FuncPtr; MatchToken(FUNC); MatchToken(L_BRACKET); tmp = Expression(); address = MakeExprNode(FUNC,funcPtr_value,tmp); MatchToken(R_BRACKET); } else if(TempToken.type == L_BRACKET){ MatchToken(L_BRACKET); address = Expression(); MatchToken(R_BRACKET); } else SyntaxError(2); return address; } }; int Parsers::cnt = 0; void DrawXY(double for_x, double for_y, double origin_x,double origin_y,double scale_x,double scale_y,double rot_ang){ double tempx, tempy; for_x *= scale_x; for_y *= scale_y; tempx = for_x; tempy = for_y; for_x = tempx * cos(rot_ang) + tempy * sin(rot_ang); for_y = tempy * cos(rot_ang) - tempx * sin(rot_ang); for_x += origin_x; for_y += origin_y; putpixel(for_x,for_y,RGB(255,255,255)); } void DrawTotalXY(Parsers P, double Origin_X,double Origin_Y,double Scale_X,double Scale_Y,double Rot_ang, double Start, double End, double Step, struct ExprNode* For_X, struct ExprNode* For_Y) { double x,y; P.Parameter = Start; if (Step \u0026gt; 0) { while (P.Parameter \u0026lt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); P.Parameter += Step; } } else if(Step \u0026lt; 0){ while (P.Parameter \u0026gt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); P.Parameter += Step; } } } int main() { Parsers P; P.Parser(); initgraph(1000, 700); for(int i = 0; i \u0026lt; Start.size(); i ++) DrawTotalXY(P,Origin_X[i],Origin_Y[i],Scale_X[i],Scale_Y[i],Rot_ang[i],Start[i],End[i],Step[i],For_X[i],For_Y[i]); _getch(); closegraph(); return 0; } ","date":"2022/11/21","externalUrl":null,"permalink":"/blogs/fglcompiler3/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 绘图器","title":"编译原理上机(3) - 绘图器","type":"blogs"},{"content":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 语法分析器\n报告及代码链接：\nZhanYirui/FGLCompiler C\u0026#43;\u0026#43; 1 0 第二部分:语法分析器(完整代码在结尾)\n测试文本:\norigin is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 语法分析器的目的是判断词法分析器得到的记号是否合法，以及记号组成的句子是否合法。\n语法分析器的设计思路:\n​ 比如文本里装的是:\n​ ORIGIN IS (-16+5**3/cos(pi),2*120);\n​ 我们通过第一部分的词法分析器就能得到一个记号流:\n​ ORIGIN IS L_BRACKET CONST_ID MUL CONST_ID COMMA CONST_ID MUL CONST_ID R_BRACKET SEMICO\n​ 我们现在从记号流里面取出第一个记号ORIGIN，所以我们要匹配OriginStatement，继续取下一个记号，要想符合OriginStatement的语法，下一个记号应该匹配IS，如果下一个记号不能匹配IS，那就语法报错后退出；如果下一个记号匹配的是IS，我们就继续匹配，如果我们在匹配过程中取到了ERRTOKEN类型的记号，那么就词法报错后退出。\n​ 所以设计思路就是:\n​ 依次取记号，如果是ERRTOKEN类型就词法报错，如果匹配不了语法，那就语法报错。\n​ 需要注意到的是括号和逗号之间的是两个表达式，所以我们要设计一个表达式树结构，比如给的这个例子我们匹配完左括号之后，要生成一个表达式树来表示-16+5**3/cos(pi)。\n表达式树的节点可以分为三类:\n​ 1.叶节点: 常数CONST_ID、参数T\n​ 2.有两个孩子的节点 也就是运算符节点: 加PLUS、减MINUS、乘MUL、除DIV、幂运算POWER (这时候有两个特例就是一元加和一元减，比如+5，这个+的左孩子就是NULL，右孩子是5，就将+5转换成5了；还有-5，这个-的左孩子就是0，右孩子就是5，就将-5转换成0-5了)\n​ 3.有一个孩子的节点 也就是函数节点: 函数FUNC\n表达式树节点代码:\ntypedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; 表达式树节点的生成，本来我是根据匹配的记号类型的不同设计四个函数生成不同类型的节点，但是PPT上给出的利用可变列表生成节点的方法更简便，代码如下。 这段代码的意思是: 如果现在匹配的是常数CONST_ID类型，那我们传进去的肯定是常数的值value，我们就可以生成一个节点，这个节点的CaseConst指针指向常数的值；如果我们匹配的是参数T类型，那就生成一个节点，这个节点的CaseParmPtr指针指向Parameter；如果我们匹配的是函数FUNC类型，那我们传进去的肯定是一个函数指针以及一个表达式树节点，那就可以生成一个节点，这个节点的MathFuncPtr指针指向传入的函数，Child孩子指针指向传入的表达式树节点；如果我们匹配的是运算符例如PLUS/MINUS这些类型，那我们传进去的肯定是两个表达式节点，那就可以生成一个节点，这个节点的Left左孩子指针指向传入的第一个节点，Right右孩子指针指向传入的第二个节点。\nstruct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } 利用递归进行表达式树的打印，注意一下，上面两段代码都是表达式树的节点的设计和生成，下面的代码是打印一整棵表达式树。通过递归先序遍历打印表达式树：传入表达式树的根节点，如果节点类型是CONST_ID那就说明这个节点只有CaseConst指针有值，打印CaseConst指针指向的值；如果节点类型是T那就打印\u0026quot;T\u0026quot;；如果节点类型是FUNC那就说明这个节点的MathFuncPtr和Child指针有值，先根据MathFuncPtr指向的函数打印函数的名称，然后用递归打印以孩子节点作为根节点的子树；如果节点类型是运算符，那就先打印运算符，然后递归打印分别以左右孩子节点为根节点的两棵子树。\nvoid OutExprNode(struct ExprNode* Tree){ cout \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34;; switch (Tree-\u0026gt;OpCode) { case CONST_ID: cout \u0026lt;\u0026lt; Tree-\u0026gt;Content.CaseConst \u0026lt;\u0026lt; endl;break; case T: cout \u0026lt;\u0026lt; \u0026#34;T\u0026#34; \u0026lt;\u0026lt; endl;break; case FUNC:{ if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sin){cout \u0026lt;\u0026lt; \u0026#34;sin\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = cos){cout \u0026lt;\u0026lt; \u0026#34;cos\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = log){cout \u0026lt;\u0026lt; \u0026#34;log\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = exp){cout \u0026lt;\u0026lt; \u0026#34;exp\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = tan){cout \u0026lt;\u0026lt; \u0026#34;tan\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sqrt){cout \u0026lt;\u0026lt; \u0026#34;sqrt\u0026#34; \u0026lt;\u0026lt; endl;} OutExprNode(Tree-\u0026gt;Content.CaseFunc.Child); }break; case PLUS:{ cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MINUS:{ cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MUL:{ cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case DIV:{ cout \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case POWER:{ cout \u0026lt;\u0026lt; \u0026#34;**\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; } } 绘图语言的文法:\nProgram -\u0026gt; { Statement SEMICO }\nStatement -\u0026gt; OriginStatement | ScaleStatement | RotStatement | ForStatement\nOriginStatement -\u0026gt; ORIGIN IS L_BRACKET Expression COMMA Expression R_BRACKET\nScaleStatement -\u0026gt; SCALE IS L_BRACKET Expression COMMA Expression R_BRACKET\nRotStatement -\u0026gt; ROT IS Expression\nForStatement -\u0026gt; FOR T FROM Expression TO Expression STEP Expression DRAW L_BRACKET Expression COMMA Expression R_BRACKET\n表达式树的产生式:\nExpression -\u0026gt; Term { ( PLUS | MINUS ) Term }\nTerm -\u0026gt; Factor { ( MUL | DIV ) Factor }\nFactor -\u0026gt; PLUS Factor | MINUS Factor | Component\nComponent -\u0026gt; Atom POWER Component | Atom\nAtom -\u0026gt; CONST_ID | T | FUNC L_BRACKET Expression R_BRACKET | L_BRACKET Expression R_BRACKET\n根据绘图语言文法和表达式树的产生式，我们可以设计一个Parsers类，在类里利用迭代实现文法和表达式树的产生。\nParsers类里我们首先定义一个构造函数 Parsers(){LoadFileTokens();} 作用是当我们创建一个Parsers类实例的时候自动调用LoadFileTokens()函数将文本的记号流装到容器里。\n先写三个辅助函数\nvoid FetchToken();\nvoid MatchToken(Token_Type t);\nvoid SyntaxError(int x);\nvoid FetchToken(); 这个函数的作用是从记号流里获取一个记号，如果获取的记号是ERRTOKEN类，就词法报错后退出\nvoid FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t); 这个函数的参数是一个单词类型，作用是将当前从记号流里获取的记号和这个单词类型进行匹配，如果不匹配就语法报错后退出，否则就获取下一个记号\nvoid MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x); 这个函数的参数是一个整数，如果整数是1就代表词法错误，如果整数是2就代表语法错误\nvoid SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No: \u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; 有一个错误记号: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No: \u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; 有一个不是预期的记号: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } 根据上面给出的文法和表达式树的产生式，我们利用迭代实现文法和表达式树的生成，我们需要下列函数\nvoid Parser();\nvoid Program();\nvoid Statement();\nvoid OriginStatement();\nvoid ScaleStatement();\nvoid ForStatement();\nvoid RotStatement();\nstruct ExprNode* Expression();\nstruct ExprNode* Term();\nstruct ExprNode* Factor();\nstruct ExprNode* Component();\nstruct ExprNode* Atom();\nParser()函数获取第一个记号，然后进入Program()函数\nvoid Parser(){ FetchToken(); Program(); } 根据上述文法 Program -\u0026gt; { Statement SEMICO }\n我们写一个 Program()函数，如下:\nvoid Program(){ while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); } } 根据上述文法 Statement -\u0026gt; OriginStatement | ScaleStatement | RotStatement | ForStatement\n我们写一个Statement()函数，如下:\nvoid Statement(){ if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); } 根据上述文法 OriginStatement -\u0026gt; ORIGIN IS L_BRACKET Expression COMMA Expression R_BRACKET\n我们写一个OriginStatement()函数，如下：// ScaleStatement()、RotStatement()、ForStatement()这三个函数根据上述文法可以类比OriginStatement()函数写一下\nvoid OriginStatement(){ MatchToken(ORIGIN); MatchToken(IS); MatchToken(L_BRACKET); origin_xptr = Expression(); MatchToken(COMMA); origin_yptr = Expression(); MatchToken(R_BRACKET); } 根据上面表达式树的产生式第一条\nExpression -\u0026gt; Term { ( PLUS | MINUS ) Term }\n写一个struct ExprNode* Expression()函数，如下:\nstruct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } 其他表达式树生成函数跟Expression()函数类似，根据上面表达式树的产生式可以类比Expression()函数依次写出来，不想分析了，放在底下完整代码里了，第二部分语法分析器结束。\n语法分析器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdarg\u0026gt; #include \u0026lt;graphics.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } typedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; class Parsers{ public: Parsers(){LoadFileTokens();} double Parameter = 0; struct ExprNode *origin_xptr, *origin_yptr, *scale_xptr, *scale_yptr, *rot_ptr, *start_ptr, *end_ptr, *step_ptr, *for_xptr, *for_yptr; static int cnt; Tokens TempToken; struct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } void OutExprNode(struct ExprNode* Tree){ cout \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34;; switch (Tree-\u0026gt;OpCode) { case CONST_ID: cout \u0026lt;\u0026lt; Tree-\u0026gt;Content.CaseConst \u0026lt;\u0026lt; endl;break; case T: cout \u0026lt;\u0026lt; \u0026#34;T\u0026#34; \u0026lt;\u0026lt; endl;break; case FUNC:{ if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sin){cout \u0026lt;\u0026lt; \u0026#34;sin\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = cos){cout \u0026lt;\u0026lt; \u0026#34;cos\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = log){cout \u0026lt;\u0026lt; \u0026#34;log\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = exp){cout \u0026lt;\u0026lt; \u0026#34;exp\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = tan){cout \u0026lt;\u0026lt; \u0026#34;tan\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sqrt){cout \u0026lt;\u0026lt; \u0026#34;sqrt\u0026#34; \u0026lt;\u0026lt; endl;} OutExprNode(Tree-\u0026gt;Content.CaseFunc.Child); }break; case PLUS:{ cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MINUS:{ cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MUL:{ cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case DIV:{ cout \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case POWER:{ cout \u0026lt;\u0026lt; \u0026#34;**\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; } } void FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Error Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Unexpected Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } void Parser(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Parser\u0026#34; \u0026lt;\u0026lt; endl; FetchToken(); Program(); cout \u0026lt;\u0026lt; \u0026#34;exit from Parser\u0026#34; \u0026lt;\u0026lt; endl; } void Program(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Program\u0026#34; \u0026lt;\u0026lt; endl; while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ;\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;exit from Program\u0026#34; \u0026lt;\u0026lt; endl; } void Statement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Statement\u0026#34; \u0026lt;\u0026lt; endl; if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); cout \u0026lt;\u0026lt; \u0026#34;exit from Statement\u0026#34; \u0026lt;\u0026lt; endl; } void OriginStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in OriginStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(ORIGIN); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ORIGIN\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; origin_xptr = Expression(); OutExprNode(origin_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; origin_yptr = Expression(); OutExprNode(origin_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from OriginStatement\u0026#34; \u0026lt;\u0026lt; endl; } void RotStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in RotStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(ROT); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ROT\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; rot_ptr = Expression(); OutExprNode(rot_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from RotStatement\u0026#34; \u0026lt;\u0026lt; endl; } void ScaleStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in ScaleStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(SCALE); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken SCALE\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; scale_xptr = Expression(); OutExprNode(scale_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; scale_yptr = Expression(); OutExprNode(scale_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from ScaleStatement\u0026#34; \u0026lt;\u0026lt; endl; } void ForStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in ForStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(FOR); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken FOR\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(T); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken T\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(FROM); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken FROM\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; start_ptr = Expression(); OutExprNode(start_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(TO); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken TO\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; end_ptr = Expression(); OutExprNode(end_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(STEP); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken STEP\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; step_ptr = Expression(); OutExprNode(step_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(DRAW); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken DRAW\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; for_xptr = Expression(); OutExprNode(for_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; for_yptr = Expression(); OutExprNode(for_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from ForStatement\u0026#34; \u0026lt;\u0026lt; endl; } struct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Term(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Factor(); while (TempToken.type == MUL || TempToken.type == DIV) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Factor(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Factor(){ struct ExprNode *left, *right; if(TempToken.type == PLUS){ MatchToken(PLUS); right = Factor(); left = NULL; right = MakeExprNode(PLUS,left,right); } else if(TempToken.type == MINUS){ MatchToken(MINUS); right = Factor(); left = MakeExprNode(CONST_ID,0.0); right = MakeExprNode(MINUS,left,right); } else right = Component(); return right; } struct ExprNode* Component(){ struct ExprNode *left, *right; left = Atom(); if(TempToken.type == POWER){ MatchToken(POWER); right = Component(); left = MakeExprNode(POWER,left,right); } return left; } struct ExprNode* Atom(){ struct ExprNode *address, *tmp; double const_value; FuncPtr funcPtr_value; if(TempToken.type == CONST_ID){ const_value = TempToken.value; MatchToken(CONST_ID); address = MakeExprNode(CONST_ID,const_value); } else if(TempToken.type == T){ MatchToken(T); address = MakeExprNode(T); } else if(TempToken.type == FUNC){ funcPtr_value = TempToken.FuncPtr; MatchToken(FUNC); MatchToken(L_BRACKET); tmp = Expression(); address = MakeExprNode(FUNC,funcPtr_value,tmp); MatchToken(R_BRACKET); } else if(TempToken.type == L_BRACKET){ MatchToken(L_BRACKET); address = Expression(); MatchToken(R_BRACKET); } else SyntaxError(2); return address; } }; int Parsers::cnt = 0; int main() { Parsers P; P.Parser(); return 0; } ","date":"2022/11/20","externalUrl":null,"permalink":"/blogs/fglcompiler2/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 语法分析器","title":"编译原理上机(2) - 语法分析器","type":"blogs"},{"content":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 词法分析器\n报告及代码链接：\nZhanYirui/FGLCompiler C\u0026#43;\u0026#43; 1 0 写在前头:\n下面给出的代码是我第一版写出来的，勉强能符合要求。我后来进行了代码的优化和功能的添加，希望各位能够借鉴我的思路自己写一遍。\n上机目的:\n例如: ORIGIN IS (360,240); \u0026ndash; 将原点平移到(360,240)位置\n​ SCALE IS (100,100); // 将横坐标和纵坐标都放大100倍\n​ SCALE IS (100,100/3); \u0026ndash; 横坐标放大100倍，纵坐标放大100/3倍\n​ ROT IS PI/2; // 图形逆时针旋转90度\n​ FOR T FROM 0 TO 2PI STEP PI/50 DRAW(cos(T),sin(T)); //画圆\n​ 这是给定的一个绘图语言，有四种语句。ORIGIN语句，作用是将原点平移；SCALE语句，作用是将横纵坐标放大；ROT语句，作用是将图形旋转；FOR语句，作用是画图；还有\u0026ndash;和//，作用是注释。\n所以上机分三个部分:\n​ (1) 词法分析器:目的是将这些语句中的单词一个个识别出来\n​ (2) 语法分析器:目的是判断词法分析器得到的单词是否有错误，以及识别到的单词组成的语句符不符合规定\n​ (3) 绘图器:通过识别到的语句进行画图\n第一部分:词法分析器 (完整代码在结尾)\n测试文本:\norigin is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 ​ 词法分析器的目的说白了就是将文件中的单词一个个提取出来并分类\n比如:ORIGIN IS (360,240); 将这个句子中的单词提取出来就是ORIGIN、IS、(、360、,、240、)、; 我们将提取到的单词进行分类，比如360和240就是同一类都是常数，于是我们可以将单词的种类分为:\n​ 保留字: ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,T\n​ 分隔符: SEMICO(;),L_BRACKET((),R_BRACKET()),COMMA(,)\n​ 运算符: PLUS(+),MINUS(-),MUL(*),DIV(/),POWER(**)\n​ 参数: T\n​ 函数: FUNC\n​ 常数: CONST_ID\n​ 结尾记号: NONTOKEN\n​ 出错记号: ERRTOKEN\n我们利用一个枚举enum类型来将单词的种类给装起来:\nenum Token_Type { ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //结尾记号 ERRTOKEN //出错记号 }; 单词有自己的属性，上面我们用enum装起来的只是单词的一个单词种类属性，单词还有文本属性，常数还有自己的值属性，函数还有自己的函数指针属性，还有每个单词在文件中的行数属性。比如Origin这个单词，它的单词种类是ORIGIN，文本是Origin，它不是常数所以值属性规定为0，也不是函数所以函数指针设为NULL；再比如360这个单词，它的单词种类是CONST_ID，文本是360，它是常数所以值属性为360，它不是函数所以函数指针设为NULL;再比如sin这个单词，它的单词种类是FUNC，文本是sin，它不是常数所以值属性为0，它是函数所以函数指针设为sin。\n所以我们用struct定义一个单词结构体:\ntypedef struct Tokens { Token_Type type; //单词种类 string lexeme; //单词的文本 double value; // 常数单词的值 double (*FuncPtr)(double); // 函数单词的函数指针 int TokenLine; // 单词在文件中的行数 } Tokens; 这时候我们意识到一个问题，当我们在文件里识别到Origin、Scale、sin、Pi这些字符串单词的时候我们要给它归类到保留字、函数、常数等我们预先定义的单词类型，但当我们识别到abcd、xyz这些字符串单词的时候，我们要给这些单词归类到ERRTOKEN类型。所以我们需要一个单词字典，当我们识别到字符串单词的时候，要先查找这个单词字典，如果在字典里没有找到，我们就要将它们归类到ERRTOKEN类型。\n所以我们定义一个单词字典:\nstatic Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; 利用C++的类，我们定义一个Scanner类。\n这个类里有三个成员变量:\n​ string FileName;\n​ string TokenBuffer;\n​ fstream F;\n其中TokenBuffer是字符串缓冲区，因为我们读文件是利用循环一个字符一个字符地读，所以我们要有一个字符串缓冲区来将字符一个个装起来。比如文件里有个Origin单词，我们读文件时，先读到一个O字母，我们把O装到缓冲区，然后再读r字母，再装到缓冲区，以此类推，到最后读完这个单词的时候，缓冲区就装了Origin这个单词的文本值了。\n类里还有七个成员函数:\n​ void OpenFile();\n​ void CloseFile();\n​ void EmptyBuffer();\n​ void AddCharToBuffer(char TempC);\n​ Tokens SearchCharInDict(string TempS);\n​ Tokens CreateTokens(Token_Type type,string lexeme,double value,double (*FuncPtr)(double),int Line);\n​ Tokens GetToken();\n接下来我依次来说明这些成员函数的作用:\nvoid OpenFile(); 这个函数作用很简单，就是输入文件名后打开文件。\nvoid OpenFile(){ // 输入文件名打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(); 这个函数就是关闭文件。\nvoid CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(); 这个函数的作用是清空缓冲区，读上一个单词的时候上一个单词的文本值还在缓冲区里面，我们读下一个单词的时候就要先清空缓冲区。\nvoid EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC); 这个函数的作用就是将一个字符装到缓冲区里面。\nvoid AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS); 这个函数的作用是查单词字典，上面我们说过了，当我们读字符串单词的时候，要先在单词字典里面进行查找，如果没找到的话要将其归类为ERRORTOKEN类型。任务规定语言对大小写不敏感，所以Origin,origin,ORIGIN都要识别为ORIGIN类型，所以我们将存在缓冲区的单词文本值传进去的时候，将其全部转换为大写字母，我这里是利用C++自带的算法库进行大写转换的。\nTokens SearchCharInDict(string TempS){ //查单词字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; //利用C++算法库进行大写转换 transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme) { T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateTokens(Token_Type type,string lexeme,double value,double (*FuncPtr)(double),int Line); 这个函数作用是传入单词的各个属性，返回一个单词，因为底下GetToken()函数在生成单词时有很多重复代码，所以就专门写了个函数进行单词生成。\nTokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ // 生成单词 Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(); 这个函数是Scanner类最核心的成员函数，作用是获取文件中的一个单词。\n设计思路:我们读文件是一个字符一个字符地读。所以我们根据读到的字符进行不同的设计。\n​ 当我们读到的字符是文件结尾字符 \u0026lsquo;EOF\u0026rsquo; 的时候，我们返回一个类型为NONTOKEN的单词。\n​ 当我们读到的字符是空格 \u0026rsquo; \u0026rsquo; 或者制表符 \u0026lsquo;\\t\u0026rsquo; 的时候，不作处理，继续读下一个字符。\n​ 当我们读到的字符是换行符 \u0026lsquo;\\n\u0026rsquo; 的时候，我们将行数加1，然后继续读下一个字符。\n​ 当我们读到的字符是字母 \u0026lsquo;[a-zA-Z]\u0026rsquo; 的时候，我们将字符装到缓冲区，然后读下一个字符，如果下一个字符还是字母，那就继续装到缓冲区，直到读的字符不是字母为止，这个时候缓冲区里面装的就是单词的文本值了。然后查单词字典，是预设的单词的话就返回一个预设的单词，不然就返回一个类型为ERRTOKEN的单词。\n​ 当我们读到的字符是数字 \u0026lsquo;[0-9]\u0026rsquo; 的时候，我们将字符装到缓冲区，然后读下一个字符，如果下一个字符还是数字，就继续装到缓冲区，直到读的字符不是数字为止。由于数字还能有小数，所以这时候如果读的字符是小数点 \u0026lsquo;.\u0026rsquo; ，那就继续装到缓冲区，然后读下一个字符，如果是数字就装到缓冲区，直到读的字符不是数字为止，这个时候缓冲区里面就是常数的文本值。最后返回一个类型为CONST_ID，值属性为利用stod()函数转换缓冲区里的文本值为常数值 的单词。\n​ 当我们读到的字符是分号 \u0026lsquo;;\u0026rsquo; 的时候，返回一个类型为SEMICO的单词。\n​ 当我们读到的字符是左括号 \u0026lsquo;(\u0026rsquo; 的时候，返回一个类型为L_BRACKET单词。\n​ 当我们读到的字符是分号右括号 \u0026lsquo;)\u0026rsquo; 的时候，返回一个类型为R_BRACKET的单词。\n​ 当我们读到的字符是逗号 \u0026lsquo;,\u0026rsquo; 的时候，返回一个类型为COMMA的单词。\n​ 当我们读到的字符是加号 \u0026lsquo;+\u0026rsquo; 的时候，返回一个类型为PLUS的单词。\n​ 当我们读到的字符是减号 \u0026lsquo;-\u0026rsquo; 的时候，由于 \u0026ndash; 是注释，我们需要继续读下一个字符，如果下一个字符不是 \u0026lsquo;-\u0026rsquo;，那么我们返回一个类型为MINUS的单词，如果下一个字符是 \u0026lsquo;-\u0026rsquo;，我们就要继续往后读，直到读的字符是换行符 \u0026lsquo;\\n\u0026rsquo; 或者结束符 \u0026lsquo;EOF\u0026rsquo; 的时候结束，要是读的是 \u0026lsquo;\\n\u0026rsquo;就将行数加1然后继续下一个循环，要是读的是 \u0026lsquo;EOF\u0026rsquo; 就返回一个类型为NONTOKEN的单词。\n​ 当我们读到的字符是除号 \u0026lsquo;/\u0026rsquo; 的时候，跟读减号 \u0026lsquo;-\u0026rsquo; 的方法一样\n​ 当我们读到的字符是乘号 \u0026lsquo;*\u0026rsquo; 的时候，由于 * 是幂次运算，我们需要继续读下一个字符，如果下一个字符不是 \u0026lsquo;*\u0026rsquo;，那么我们返回一个类型为MUL的单词，如果下一个字符是 \u0026lsquo;*\u0026rsquo;，我们就返回一个类型为POWER的单词。*\nTokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;){ c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } Scanner类我们就已经设计好了，这个时候我选择用一个循环反复调用GetToken()函数将文件里面的所有单词存放到一个容器里面，后面设计语法分析器的时候就可以直接从容器里面取了，不过这也是看个人喜好，用一次调一次GetToken()函数也可以。\nvector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens() { Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } 再然后就是打印所有单词了，就不写了，直接放到完整代码里面，词法分析器部分就结束了。\n词法分析器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iomanip\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } void Cout(string type, string lexeme, double value, string funcptr){ cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; type \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; lexeme \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(14) \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(16) \u0026lt;\u0026lt; funcptr \u0026lt;\u0026lt; endl; } void COUT(Tokens t){ switch (t.type) { case ORIGIN:Cout(\u0026#34;ORIGIN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case SCALE:Cout(\u0026#34;SCALE\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case ROT:Cout(\u0026#34;ROT\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case IS:Cout(\u0026#34;IS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case TO:Cout(\u0026#34;TO\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case STEP:Cout(\u0026#34;STEP\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case DRAW:Cout(\u0026#34;DRAW\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FOR:Cout(\u0026#34;FOR\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FROM:Cout(\u0026#34;FROM\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case T:Cout(\u0026#34;T\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case SEMICO:Cout(\u0026#34;SEMICO\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case L_BRACKET:Cout(\u0026#34;L_BRACKET\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case R_BRACKET:Cout(\u0026#34;R_BRACKET\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case COMMA:Cout(\u0026#34;COMMA\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case PLUS:Cout(\u0026#34;PLUS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case MINUS:Cout(\u0026#34;MINUS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case MUL:Cout(\u0026#34;MUL\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case DIV:Cout(\u0026#34;DIV\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case POWER:Cout(\u0026#34;POWER\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FUNC:{ string temp = t.lexeme; transform(temp.begin(),temp.end(),temp.begin(),::toupper); Cout(\u0026#34;FUNC\u0026#34;,t.lexeme,t.value,temp); };break; case CONST_ID:Cout(\u0026#34;CONST_ID\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; case NONTOKEN:Cout(\u0026#34;NONTOKEN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; case ERRTOKEN:Cout(\u0026#34;ERRTOKEN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; } } int main() { LoadFileTokens(); cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; \u0026#34;Token_Type\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; \u0026#34;String_Value\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(14) \u0026lt;\u0026lt; \u0026#34;Constant_Value\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(16) \u0026lt;\u0026lt; \u0026#34;Function_Pointer\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-------------------------------------------------------------------------------------\u0026#34; \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; TokenStream.size(); i ++) COUT(TokenStream[i]); return 0; } ","date":"2022/11/19","externalUrl":null,"permalink":"/blogs/fglcompiler1/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 词法分析器","title":"编译原理上机(1) - 词法分析器","type":"blogs"},{"content":"","date":"0001/1/1","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001/1/1","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001/1/1","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]