
[{"content":"","date":"2024/6/12","externalUrl":null,"permalink":"/blogs/","section":"Blogs","summary":"","title":"Blogs","type":"blogs"},{"content":"","date":"2024/6/12","externalUrl":null,"permalink":"/","section":"Enly","summary":"","title":"Enly","type":"page"},{"content":"","date":"2024/6/12","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024/6/12","externalUrl":null,"permalink":"/tags/%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/","section":"Tags","summary":"","title":"软件与系统安全","type":"tags"},{"content":"软件与系统安全笔记 - 代码混淆\n代码混淆 # 代码混淆（Obfuscation）是一种在软件保护领域广泛应用的技术，其主要目的是为了提高程序代码的阅读和理解难度，从而阻碍逆向工程(reverse engineering)的进行。这一技术通过修改源代码、字节码或二进制代码，使代码在功能上保持不变，但其结构、变量名、函数名等被改写得难以理解，增加了非法分析者逆向分析软件以获取其内部逻辑、算法或敏感信息的难度。\n混淆的主要技术手段包括但不限于：\n数据混淆：对常量、字符串等数据进行加密或编码，运行时再解密使用，使得静态分析中难以直接看到原始数据。 控制流混淆：通过插入无意义的跳转、条件分支等，改变代码的正常执行流程，但确保最终结果不变，这大大增加了分析的复杂度。 模型与层次\n输入与输出程序的语义等价：混淆过程必须保证处理后的程序在功能上与原程序完全一致，只是表现形式不同，这是混淆的基本原则。 混淆的层次： 源代码级混淆：直接对高级编程语言的源代码进行修改。 汇编/二进制级混淆：在编译后的机器代码层面进行操作，这通常涉及到更底层的指令重写和优化。 中间代码/字节码级混淆：对于像Java、.NET这类平台，可以在其字节码或中间代码（如Java bytecode, MSIL）上进行混淆，这是较为常见的混淆方式，因为这类代码比源代码更接近机器码，同时仍保留了一定程度的平台独立性和可操作性。 完美混淆器 # 对于一个概率算法O，完美混淆器需要满足下面三个条件：\n功能性（Functionality）: 这意味着混淆后的程序O(P)必须保持与原程序P完全相同的功能。也就是说，对于任何可能的输入x，O(P)(x)和P(x)的结果必须一致。这一条件保证了混淆过程不改变程序的行为，只是改变了其表现形式。 多项式减速（Polynomial Slowdown）: 混淆后的程序在最坏情况下的运行时间（时间和空间复杂度）相比原程序最多只能是多项式级别的增长。这是为了确保混淆虽然增加了程序的复杂度，但仍然保持了实用性和效率。 虚拟黑盒（Virtual Black-Box, VBB）属性: 这是最关键也是最具挑战性的条件。它要求即使一个具有强大计算能力的攻击者，拥有混淆程序O(P)的完整源代码或二进制代码，并且能够在多项式时间内执行任意复杂的计算，也无法从O(P)中学到关于原程序P的任何额外信息，除了通过反复执行O(P)并观察输出（即所谓的黑盒测试）所能获取的信息。简而言之，混淆后的程序对于攻击者来说就像一个黑盒，尽管他们可以看到盒子内部的每一个细节，但是仍无法理解其工作原理或逆推出原始程序的结构。 数据混淆 # 常量展开 # 假设程序在某处使用了一个常量值，可以利用一个计算过程代替这个常量值，而这个计算过程的结果就是这个常量值\n比如：x = 4 可以混淆成 x = 2 + 2\n数据编码 # 数据编码是将原始数据转换成不易识别的编码数据来增加逆向工程的难度。\n假设有一个编码函数f(x)：\n混淆：将x0 -\u0026gt; f(x0） 解混淆：将f(x0) -\u0026gt; x0。 编码函数f必须满足：\n给定f(x)，无法推测出x 给定x和f(x)，无法推测出f 多项式编码\n多项式编码通过将数据映射到多项式的值上来实现混淆。\nf(x) = a_nx^n + \u0026hellip; + a_1x + a_0。\n这种方法的优势在于，即使攻击者知道多个 (x,f(x)) 对，直接从多项式系数逆推出原始数据或多项式本身也相对困难，尤其是当多项式的阶数较高时。\n剩余数编码\n剩余数编码基于模运算，先选择几个互质的模m1, m2, \u0026hellip; , mk，然后将原始数据x对这些模分别取余得到 y1 = x mod m1, y2 = x mod m2, \u0026hellip; yk = x mod mk。解码的时候，需要通过中国剩余定理或其他算法利用y1,\u0026hellip;yk和m1,\u0026hellip;mk求出x。这种方法增加了逆向分析的复杂度，因为攻击者需要处理多个模运算的关系，而非单一的直接转换。\n同态编码\n一般的编码方案在运行前需要动态解码，会引入额外的计算开销，并可能暴露解码逻辑。而同态编码允许直接利用编码后的数据进行计算，而无需先解码再运算。\n对于两个群G,H，如果存在一个映射f: G -\u0026gt; H，且对于两个元素x, y属于G，那么f(x),f(y)属于H，那么f如果是个同态映射，就意味着f(x +g y) = f(x) +h f(y)，其中+g是群G中的运算，+h是群H中的运算。\n举个例子：\nx1和x2，混淆后分别为f(x1)和f(x2)，运行时如果要计算x1*x2，需要先把f(x1)-\u0026gt;x1，f(x2)-\u0026gt;x2，再进行运算。而同态编码允许运行的时候直接计算f(x1) * f(x2) = f(x1 * x2) -\u0026gt; x1 * x2。种性质使得可以在保护隐私的同时处理数据，特别适用于云计算和数据安全领域。\n将同态的概念应用于代码混淆或数据保护时，我们可以构建这样的系统：源代码或数据在某个“未编码域”（原始的、易理解的形式）中定义，对应于代数结构G；通过一个同态映射f，这些源代码或数据被转换到“编码域”（混淆的、难以解读的形式），对应于另一个代数结构H。关键在于，这个映射不仅要保证混淆后的数据在功能上等价于原数据，而且要在H中定义一套运算规则，使得对编码后数据的操作结果，经过逆映射后，等同于原数据在G中直接操作的结果。\n全同态加密就是能进行任意运算，不管加法、乘法乃至更复杂的操作，都满足上面的定义。\n基于模式的混淆 # 基于模式的混淆就是将简单的、容易理解的指令替换为功能等价但更为复杂的指令。\n举个例子：\n-x -\u0026gt; ~x+1\n在计算机中，对一个数取负数，等价于对这个数取反并加1。\n比如整数1，二进制为0001，对0001进行取反并+1后就是1111。而1111代表的就是-1。\n控制流混淆 # 二进制静态分析对控制流的假定 # CALL指令只用于函数调用, 且调用目标即函数的起始地址\n绝大多数函数调用会返回, 且返回到CALL指令的后一条指令的位 置; RET和RETN代表函数边界\n遇到条件跳转时, 假定: 分支两侧均可能被执行; 分支两侧均为代码而非数据\n容易确定间接跳转的目标地址\n只有switch结构能够生成间接跳转; 只有对函数指针的调用能够 生成间接调用\n所有控制转移目标地址都是代码而非数据\n异常以一种可预测的方式使用\n控制流混淆旨在通过改变程序的正常控制流程，使得攻击者难以理解和分析程序的行为。\n打破CALL指令的直接关联: 通常，CALL指令被假定为仅用于函数调用，并且其目标是函数的起始地址。混淆技术可以插入无意义的CALL指令到非函数起始位置，或者使用自定义的跳转指令代替标准的CALL，使得分析者难以区分真实函数调用与混淆指令。\n扰乱函数返回流: 通过在函数返回点插入额外的跳转指令，或者使用非标准的返回机制（如返回到非CALL之后的位置），混淆技术可以使程序的返回流程变得难以追踪。此外，还可以使用“花指令”（无意义的指令序列）来混淆函数的退出路径。\n复杂化条件跳转: 改变条件跳转的逻辑，引入看似无关的条件检查，或者使用复杂的计算来决定跳转目标，使分析者难以判断分支行为。同时，也可以将数据区域伪装成可执行代码，让分析工具误以为数据也是潜在的控制流部分。\n间接跳转目标的隐蔽化: 利用动态计算的跳转表、随机化或加密跳转目标地址，使得间接跳转的目的地在静态分析时难以确定。这包括对switch-case结构的混淆和对函数指针调用的隐藏，使得它们的目标不再是显而易见的。\n混淆代码与数据边界: 将代码片段嵌入到数据区域，或将数据块布置得像可执行代码，混淆分析者对内存区域的直观判断。这样，即使是间接跳转，也可能指向看似数据的区域，实际上却执行了代码。\n异常处理的混淆: 通过异常处理机制插入混淆代码，或者将正常的控制流逻辑伪装成异常处理路径，可以进一步模糊程序的实际执行流程。异常的触发和处理方式变得不透明，增加了逆向工程的难度。\n组合使用函数内联与外联 # 函数内联：将函数的代码直接复制到调用的地方。\n比如：\nint add(x, y){ return x + y; } int main(){ int x = 1; int y = 2; int z = add(x, y); return 0; } ### 函数内联 ### ### 直接将add函数的代码块复制到main函数里，变为：### int main(){ int x = 1; int y = 2; int z = x + y; return 0;\t} 函数外联：与函数内联相反，将一部分代码抽离出来单独写个函数，然后将代码块的部分替换为函数的调用。\n通过跳转破坏局部性 # 通过跳转的思想是打乱代码的自然执行顺序。\n在未经混淆的在未经混淆的程序中，代码通常按照逻辑上的连续性和相关性组织，形成了良好的局部性，便于人类理解和分析。控制流图（CFG，Control Flow Graph）中的基本块（Basic Block）通常紧密相连，代表了直接的执行序列。通过在基本块中不必要地插入无条件跳转（Jump）或goto语句，可以打破这种自然的执行流，使得相邻的语句在执行时可能相隔甚远，或者使得代码执行路径变得错综复杂。\n比如，原本连续的几行代码：\nA; // 执行语句A B; // 执行语句B C; // 执行语句C D; // 执行语句D E; // 执行语句E F; // 执行语句F 在经过跳转混淆后可能会变成：\nA; // 执行语句A jump to D; B; // 执行语句B jump to E; C; // 执行语句C jump to F; D: jump to B; E: jump to C; F: // 正常继续执行后续代码 这种混淆方法极大地混淆了代码的直观阅读，使得分析者难以直接通过阅读代码逻辑来理解程序的工作方式。\n不透明谓词 # 不透明谓词就是一种特殊的条件判断语句，但是这个条件判断语句的值只有混淆者知道，对于攻击者而言很难判断这个条件判断语句的值。\n不透明谓词的分类\nPT（Always True）: 这类不透明谓词在编译或混淆阶段已知其值永远为真。将其作为分支条件插入代码中，不会实际改变执行路径，但对于不知情的分析者来说，它会掩盖真实控制流程，让其看起来仿佛有额外的分支选择。 PF（Always False）: 相对于PT，PF类型的不透明谓词在混淆时确定其值总是假。同样，它也被用作条件判断，可以引入看似可能影响控制流但实际上恒不被执行的代码路径。 P?（Indeterminate）: 这类不透明谓词的值在混淆时可能为真也可能为假，但其确定性对于外部分析者来说难以判断。利用P?可以创建更加复杂的混淆效果，使得分析者难以区分哪些分支是真正有意义的，只有混淆者才能知道哪些分支才真正有意义。 不透明谓词的应用\n增加伪分支：在程序的关键路径中插入基于不透明谓词的条件分支，可以创建出额外的控制流路径，这些路径要么永远不被执行，要么其执行与否对程序逻辑没有实际影响。这种做法能够显著增加控制流图（CFG）的复杂度，使逆向分析更加困难。 混淆条件逻辑：在实际的逻辑判断中嵌入不透明谓词，即使这些谓词的值对结果没有影响。例如，一个简单的布尔逻辑if (condition \u0026amp;\u0026amp; PT)，其中condition是真实逻辑判断，而PT是始终为真的不透明谓词，这种组合使得分析者难以分辨condition的真实作用。 举几个例子：\n如果我们想执行A，可以将PT放到if的判断里，由于PT的值恒true，运行的时候只会执行A，不可能执行B。但是对于攻击者而言，他无法判断PT的值，所以他会觉得B也是有可能执行的。\nif (PT) { A; // 执行A } else { B; // 执行B } PF的值恒为false，所以不可能执行C，这个分支毫无意义，但是对于攻击者而言，他无法判断PF的值，所以会消耗成本去分析这个假分支。\nif (PF) { C; // 执行C } 插入无效代码 # 死代码（Dead Code）插入\n目的：侧重于数据混淆，通过修改或操作不会影响程序最终结果的“死”变量或寄存器，使得分析者难以区分哪些数据操作是真正有用的。\n示例：\nint f() { int x, y; x = 1; // 下面的代码是死代码，因为x的值在被使用前会被重新赋值 x = x + 2; // y从未被使用，属于死代码 y = 2; // 在此之前，x的初始值未被使用，是\u0026#34;死\u0026#34;的，但此处赋值后变为\u0026#34;活\u0026#34; x = 3; return x; } 垃圾代码（Junk Code）插入\n目的：侧重于控制流混淆，通过在永远不会执行到的程序分支中插入大量无用代码，使得控制流显得更加复杂，增加分析难度。\n实现：混淆器识别出程序中的无用分支（例如，基于不透明谓词的总是为真或为假的分支），并在这些分支内填充大量看似执行逻辑但实际无效的代码。\n注意：与死代码相比，垃圾代码强调的是其位于不可达的代码路径上，因此即便其操作了“活”的变量或寄存器，也不会影响程序的正常执行。\n控制流间接化 # 控制流间接化是混淆技术中一种高级策略，它通过动态计算分支和调用目标地址，以及模拟处理器指令，使得控制流分析更加困难。\nJMP指令间接化\n将直接跳转指令（如JMP \u0026lt;目标地址\u0026gt;）间接化，可以使用以下模式：\nPUSH \u0026lt;目标地址\u0026gt; RET 这种间接跳转方式通过将目标地址压栈，然后执行RET指令（相当于弹出栈顶内容至EIP寄存器），实现了跳转。这种方式使得静态分析时难以直接确定跳转目标，因为目标地址是在运行时计算和压栈的。\nCALL指令间接化及其扩展\n对于CALL \u0026lt;目标地址\u0026gt;指令，可以通过以下模式进行间接化，并在目标地址处进行相应处理以保持控制流的完整性：\n地址x: CALL \u0026lt;目标地址\u0026gt; 地址x+5: \u0026lt;垃圾代码\u0026gt; ; 可选，进一步混淆 ... 目标地址: ADD ESP, 4 ; 清除CALL压入的返回地址 ; 接下来是实际的函数代码 此间接化方式同样隐藏了直接调用关系，CALL指令通过栈传递目标地址，到达目标函数后首先清理栈顶的返回地址（通常CALL指令会自动压入返回地址到栈上），然后继续执行函数代码。\n更改返回地址与模拟返回流程\n在某些混淆场景中，为了进一步混淆控制流，会修改函数的返回流程，例如：\nCALL \u0026lt;函数A\u0026gt; 原始返回地址: \u0026lt;垃圾代码\u0026gt; ; 可能包含误导性指令 ... 实际返回地址: NOP ; 或其他不影响EIP移动的指令 ... 在函数A结束时，为了返回到正确的地址，可能需要特殊处理：\n函数A起始地址: ADD [ESP], 9 ; 假设ESP当前指向返回地址上方9字节的位置，此操作实际上是跳过了垃圾代码 RET 这种技巧通过修改栈上的返回地址（通常是向上或向下调整栈指针），使得执行流绕过混淆插入的“垃圾代码”部分，直接跳转到实际的返回点，从而保证程序的正确执行，同时也极大地混淆了分析者对控制流的理解。\n通过这些间接化和模拟技术，控制流混淆极大地增加了逆向工程的难度，不仅使得静态分析工具难以准确识别代码结构，也使得手动分析更加复杂和耗时。不过，这类混淆手段需要仔细设计以避免对性能造成过大影响，并确保程序的正确性。\n控制流图扁平化 # 将程序原有的多层嵌套控制结构（如条件分支、循环等）打散并重新组织，通过一个中心分发器来控制程序的执行流程。将本来的代码分成几个基本的块，然后通过中心分发器来连接这些基本块；基本块之间的关系被隐藏在基本块之中。\n举个例子：\nint a,b; a=1; b=2; while(a\u0026lt;10){ b=a+b; if(b\u0026gt;10) b--; a++; } use(b); 画出上面这个控制流图，为： 通过switch这个中心分发器，我们可以将上面的程序更改为：\nint a, b, swVar; start: switch(swVar){ case 1: a = 1; b = 2; swVar = 2; goto start; case 2: if (a \u0026lt; 10){ swVar = 3; } else { swVar = 6; } goto start; case 3: b = b + a; if (b \u0026gt; 10){ swVar = 5; } else { swVar = 4; } goto start; case 4: b --; swVar = 5; goto start; case 5: a ++; swVar = 2; goto start; case 6: use(b); } 控制流图为：\n","date":"2024/6/12","externalUrl":null,"permalink":"/blogs/codeobfuscation/","section":"Blogs","summary":"软件与系统安全笔记 - 代码混淆","title":"软件与系统安全笔记 - 代码混淆","type":"blogs"},{"content":"生日：2003.11.13\n现就读于西安电子科技大学网安实验班大三\n这个博客的目的是记录我的学习历程\n","date":"2024/5/18","externalUrl":null,"permalink":"/about/","section":"Enly","summary":"生日：2003.11.13","title":"About","type":"page"},{"content":"","date":"2023/11/13","externalUrl":null,"permalink":"/tags/conda/","section":"Tags","summary":"","title":"Conda","type":"tags"},{"content":"macOS安装及卸载Miniconda教程\n1 安装 # 查看你要安装的版本 打开 Miniconda版本仓库，复制你要安装版本的名字，注意是.sh后缀的文件名。\n不要点击链接下载！！！ 只复制文件的名字，例如Miniconda3-py39_24.4.0-0-MacOSX-arm64.sh。 快速命令行安装 打开终端执行以下命令：\nmkdir -p ~/miniconda3 curl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh -o ~/miniconda3/miniconda.sh bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3 rm -rf ~/miniconda3/miniconda.sh 第二行命令中的Miniconda3-latest-MacOSX-arm64.sh适用于苹果M芯片的最新Miniconda版本。如果你是Intel芯片，或者想安装其他版本，请将你在步骤1)中复制的版本名替换上面第二行命令中的Miniconda3-latest-MacOSX-arm64.sh 安装后，初始化新安装的Miniconda，打开终端执行以下命令：\n~/miniconda3/bin/conda init bash ~/miniconda3/bin/conda init zsh 2 conda配置国内镜像源 # 推荐配置中科大镜像源，其他镜像源可以自行搜索配置。\n打开命令行执行以下命令：\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ conda config --set show_channel_urls yes 显示现有安装源：\nconda config --show channels 恢复默认源：\nconda config --remove-key channels 移除某个源：\nconda config --remove channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ 3 conda常用命令 # 功能 命令 获取版本号 conda -v 获取帮助 conda -h 创建环境 conda create -n environment_name 创建指定python版本下包含某些包的环境 conda create -n environment_name python= 3.7 numpy scipy 进入环境 conda activate environment_name 退出环境 conda deactivate 删除环境 conda remove -n environment_name - -all 列出所有环境 conda env list 将旧环境复制到新环境 conda create - -name new_env_name - -clone old_env_name 安装包 conda instal package_name 查看当前环境包列表 conda list 查看指定环境包列表 conda list -n environment_name 查看conda源中包的信息 conda search package_name 更新包 conda update package_name 删除包 conda remove package_name 清理无用的安装包 conda clean -p 清理tar包 conda clean -t 清理所有安装包及cache conda clean -y - -all 4 卸载 # 使用Anaconda-Clean包删除所有与conda相关的文件和目录： conda activate environment_name conda install anaconda-clean anaconda-clean 删除整个目录 rm -rf ~/miniconda3 删除PATH环境变量中的conda路径 将# \u0026raquo;\u0026gt; conda initialize \u0026raquo;\u0026gt;和# \u0026laquo;\u0026lt; conda initialize \u0026laquo;\u0026lt;之间的所有内容删除 vim ~/.bash_profile 进入vim后按i进入编辑模式，删除完后按:wq!进行保存并退出。保存后执行下面的命令。 source ~/.bash_profile 同理，对zsh也执行上述操作。\nvim ~/.zshrc source ~/.zshrc 删除配置文件 rm -rf ~/.condarc ","date":"2023/11/13","externalUrl":null,"permalink":"/blogs/condainstall/","section":"Blogs","summary":"macOS安装及卸载Miniconda教程","title":"macOS安装及卸载Miniconda教程","type":"blogs"},{"content":"动手学深度学习 - 《 Dive into Deep Learning 》学习笔记\n","date":"2023/7/22","externalUrl":null,"permalink":"/blogs/diveintodeeplearning/","section":"Blogs","summary":"动手学深度学习 - 《 Dive into Deep Learning 》学习笔记","title":"动手学深度学习笔记","type":"blogs"},{"content":"","date":"2023/7/22","externalUrl":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"机器学习","type":"tags"},{"content":"","date":"2023/7/22","externalUrl":null,"permalink":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"深度学习","type":"tags"},{"content":"西瓜书 - 《 机器学习 》学习笔记 - 9-16章\n第9章 聚类 # 第10章 降维与度量学习 # 第11章 特征选择与稀疏学习 # 第12章 计算学习理论 # 第13章 半监督学习 # 第14章 概率图模型 # 第15章规则学习 # 第16章 强化学习 # ","date":"2023/4/23","externalUrl":null,"permalink":"/blogs/watermelonnote2/","section":"Blogs","summary":"西瓜书 - 《 机器学习 》学习笔记 - 9-16章","title":"西瓜书笔记(下)","type":"blogs"},{"content":"西瓜书 - 《 机器学习 》 学习笔记 - 1-8章\n第1章 绪论 # 第2章 模型评估与选择 # 第3章 线性模型 # 第4章 决策树 # 第5章 神经网络 # 第6章 支持向量机 # 第7章 贝叶斯分类 # 第8章 集成学习 # ","date":"2023/4/12","externalUrl":null,"permalink":"/blogs/watermelonnote1/","section":"Blogs","summary":"西瓜书 - 《 机器学习 》 学习笔记 - 1-8章","title":"西瓜书笔记(上)","type":"blogs"},{"content":"","date":"2022/11/21","externalUrl":null,"permalink":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"Tags","summary":"","title":"编译原理","type":"tags"},{"content":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 绘图器\n报告及代码链接：\nZhanYirui/FGLCompiler C\u0026#43;\u0026#43; 1 0 第三部分:绘图器 (完整代码在最后)\n测试文本:\nOrigin Is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 ​ 绘图器的代码是在第二部分语法分析器的基础上改编来的。\n首先我们把第二部分语法分析器Parsers类里面的Parser()、Program()\u0026hellip;、ForStatement()成员函数里面的\u0026quot;enter in\u0026quot;、\u0026ldquo;exit from\u0026quot;以及\u0026quot;matchtoken\u0026quot;语句删除。\n在Parsers类的OriginStatement()、ScaleStatement()、RotStatement()、ForStatement()函数里面，我们得到了很多棵表达式树，在语法分析器里面我们是将它们用OutExprNode()函数先序遍历打印出来的，但是在绘图器里面，我们不需要把表达式树打印出来，我们需要表达式树它最终求出来的值，所以我们要把OutExprNode()函数改成GetExpValue()函数，两个函数很相似都是利用递归，我在语法分析器里已经分析过了，下面直接给出GetExpValue()函数的代码:\ndouble GetExpValue(struct ExprNode* Tree) { if (Tree == NULL) return 0.0; switch (Tree-\u0026gt;OpCode) { case PLUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) + GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MINUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) - GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MUL: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) * GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case DIV: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) / GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case POWER: return pow(GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left), GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right)); case FUNC: return Tree-\u0026gt;Content.CaseFunc.MathFuncPtr(GetExpValue(Tree-\u0026gt;Content.CaseFunc.Child)); case CONST_ID: return Tree-\u0026gt;Content.CaseConst; case T: return *(Tree-\u0026gt;Content.CaseParmPtr); default: return 0.0; } } 我们将语法分析器中的OutExprNode()函数换成GetExpValue()函数，这时候我们就能得到原点平移的横纵坐标的值origin_x和origin_y，横纵坐标放缩的值scale_x和scale_y，旋转的弧度值rot_ang，绘图时候参数T的起始值start、结束值end和步长step，但是现在注意了，FOR语句后面括号里面那两棵表达式树(struct ExprNode*)for_xptr,for_yptr里面带有参数T，所以我们不能直接在ForStatement()函数里面将这两棵表达式树的值求出来，而且根据要求，文件中Origin、Scale、Rot语句只影响它们后面的For语句，而且一个文件里面可以有多个FOR语句，所以我们在获得FOR语句括号里的两棵表达式树之后，我们要拿七个double容器将origin_x,origin_y,scale_x,scale_y,start,end,step装起来，拿两个struct ExprNode*容器将for_xptr和for_yptr装起来，这个时候这九个容器同一个下标里的内容就可以画出一个图形，ForStatement()函数改编后如下:\nvoid ForStatement(){ MatchToken(FOR); MatchToken(T); MatchToken(FROM); start_ptr = Expression(); start = GetExpValue(start_ptr); MatchToken(TO); end_ptr = Expression(); end = GetExpValue(end_ptr); MatchToken(STEP); step_ptr = Expression(); step = GetExpValue(step_ptr); MatchToken(DRAW); MatchToken(L_BRACKET); for_xptr = Expression(); For_X.push_back(for_xptr); MatchToken(COMMA); for_yptr = Expression(); For_Y.push_back(for_yptr); Origin_X.push_back(origin_x); Origin_Y.push_back(origin_y); Scale_X.push_back(scale_x); Scale_Y.push_back(scale_y); Rot_ang.push_back(rot_ang); Start.push_back(start); End.push_back(end); Step.push_back(step); MatchToken(R_BRACKET); } 现在我们有九个容器，每个容器都装着图形的一个参数，下一步就是来画图了。\n我利用的是EasyX，Clion下EasyX的配置教程参考: (8条消息) 在Clion中使用EasyX配置_Shine.Zhang的博客-CSDN博客\n只要能用\u0026lt;graphics.h\u0026gt;库就行了，各位自己去寻找导入方法吧。\n接下来先写一个画单个点的函数void DrawXY(double for_x, double for_y, double origin_x, double origin_y, double scale_x, double scale_y, double rot_ang)，传进去的是点的坐标、横纵坐标平移值、横纵坐标拉伸值以及旋转弧度值，代码如下:\nvoid DrawXY(double for_x, double for_y, double origin_x,double origin_y,double scale_x,double scale_y,double rot_ang){ double tempx, tempy; for_x *= scale_x; for_y *= scale_y; tempx = for_x; tempy = for_y; for_x = tempx * cos(rot_ang) + tempy * sin(rot_ang); for_y = tempy * cos(rot_ang) - tempx * sin(rot_ang); for_x += origin_x; for_y += origin_y; putpixel(for_x,for_y,RGB(255,255,255)); } 上面这段代码先将横纵坐标分别乘横纵坐标拉伸值，再根据旋转的规则:旋转后横坐标=旋转前横坐标cos(旋转弧度)+旋转前纵坐标sin(旋转弧度)，旋转后纵坐标=旋转前纵坐标cos(旋转弧度)-旋转前横坐标sin(旋转弧度) 将旋转后的横纵坐标求出来，再分别加上横纵坐标平移值，就得到了操作后的点，最后用putpixel()函数将点画出来。\n接下来我们就要通过循环令Parameter变量不断变化从而画出所有点，DrawTotalXY函数如下:\nvoid DrawTotalXY(Parsers P, double Origin_X,double Origin_Y,double Scale_X,double Scale_Y,double Rot_ang, double Start, double End, double Step, struct ExprNode* For_X, struct ExprNode* For_Y) { double x,y; Parameter = Start; if (Step \u0026gt; 0) { while (Parameter \u0026lt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); Parameter += Step; } } else if(Step \u0026lt; 0){ while (Parameter \u0026gt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); Parameter += Step; } } } 最后在main函数里面，我们通过下标从九个容器中取参数传到DrawTotalX函数里面画出所有的图像即可，完整代码如下，绘图器部分就完成了，这次上机也完成了。\n绘图器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdarg\u0026gt; #include \u0026lt;graphics.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } typedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; vector\u0026lt;double\u0026gt; Origin_X; vector\u0026lt;double\u0026gt; Origin_Y; vector\u0026lt;double\u0026gt; Scale_X; vector\u0026lt;double\u0026gt; Scale_Y; vector\u0026lt;double\u0026gt; Rot_ang; vector\u0026lt;double\u0026gt; Start; vector\u0026lt;double\u0026gt; End; vector\u0026lt;double\u0026gt; Step; vector\u0026lt;struct ExprNode*\u0026gt; For_X; vector\u0026lt;struct ExprNode*\u0026gt; For_Y; class Parsers{ public: Parsers(){LoadFileTokens();} struct ExprNode *origin_xptr, *origin_yptr, *scale_xptr, *scale_yptr, *rot_ptr, *start_ptr, *end_ptr, *step_ptr, *for_xptr, *for_yptr; double Parameter = 0, origin_x = 0, origin_y = 0, scale_x = 1, scale_y = 1, rot_ang = 0, start, end, step; static int cnt; Tokens TempToken; struct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } double GetExpValue(struct ExprNode* Tree) { if (Tree == NULL) return 0.0; switch (Tree-\u0026gt;OpCode) { case PLUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) + GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MINUS: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) - GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case MUL: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) * GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case DIV: return GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left) / GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right); case POWER: return pow(GetExpValue(Tree-\u0026gt;Content.CaseOperator.Left), GetExpValue(Tree-\u0026gt;Content.CaseOperator.Right)); case FUNC: return Tree-\u0026gt;Content.CaseFunc.MathFuncPtr(GetExpValue(Tree-\u0026gt;Content.CaseFunc.Child)); case CONST_ID: return Tree-\u0026gt;Content.CaseConst; case T: return *(Tree-\u0026gt;Content.CaseParmPtr); default: return 0.0; } } void FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Error Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Unexpected Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } void Parser(){ FetchToken(); Program(); } void Program(){ while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); } } void Statement(){ if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); } void OriginStatement(){ MatchToken(ORIGIN); MatchToken(IS); MatchToken(L_BRACKET); origin_xptr = Expression(); origin_x = GetExpValue(origin_xptr); MatchToken(COMMA); origin_yptr = Expression(); origin_y = GetExpValue(origin_yptr); MatchToken(R_BRACKET); } void RotStatement(){ MatchToken(ROT); MatchToken(IS); rot_ptr = Expression(); rot_ang = GetExpValue(rot_ptr); } void ScaleStatement(){ MatchToken(SCALE); MatchToken(IS); MatchToken(L_BRACKET); scale_xptr = Expression(); scale_x = GetExpValue(scale_xptr); MatchToken(COMMA); scale_yptr = Expression(); scale_y = GetExpValue(scale_yptr); MatchToken(R_BRACKET); } void ForStatement(){ MatchToken(FOR); MatchToken(T); MatchToken(FROM); start_ptr = Expression(); start = GetExpValue(start_ptr); MatchToken(TO); end_ptr = Expression(); end = GetExpValue(end_ptr); MatchToken(STEP); step_ptr = Expression(); step = GetExpValue(step_ptr); MatchToken(DRAW); MatchToken(L_BRACKET); for_xptr = Expression(); For_X.push_back(for_xptr); MatchToken(COMMA); for_yptr = Expression(); For_Y.push_back(for_yptr); Origin_X.push_back(origin_x); Origin_Y.push_back(origin_y); Scale_X.push_back(scale_x); Scale_Y.push_back(scale_y); Rot_ang.push_back(rot_ang); MatchToken(R_BRACKET); } struct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Term(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Factor(); while (TempToken.type == MUL || TempToken.type == DIV) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Factor(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Factor(){ struct ExprNode *left, *right; if(TempToken.type == PLUS){ MatchToken(PLUS); right = Factor(); left = NULL; right = MakeExprNode(PLUS,left,right); } else if(TempToken.type == MINUS){ MatchToken(MINUS); right = Factor(); left = MakeExprNode(CONST_ID,0.0); right = MakeExprNode(MINUS,left,right); } else right = Component(); return right; } struct ExprNode* Component(){ struct ExprNode *left, *right; left = Atom(); if(TempToken.type == POWER){ MatchToken(POWER); right = Component(); left = MakeExprNode(POWER,left,right); } return left; } struct ExprNode* Atom(){ struct ExprNode *address, *tmp; double const_value; FuncPtr funcPtr_value; if(TempToken.type == CONST_ID){ const_value = TempToken.value; MatchToken(CONST_ID); address = MakeExprNode(CONST_ID,const_value); } else if(TempToken.type == T){ MatchToken(T); address = MakeExprNode(T); } else if(TempToken.type == FUNC){ funcPtr_value = TempToken.FuncPtr; MatchToken(FUNC); MatchToken(L_BRACKET); tmp = Expression(); address = MakeExprNode(FUNC,funcPtr_value,tmp); MatchToken(R_BRACKET); } else if(TempToken.type == L_BRACKET){ MatchToken(L_BRACKET); address = Expression(); MatchToken(R_BRACKET); } else SyntaxError(2); return address; } }; int Parsers::cnt = 0; void DrawXY(double for_x, double for_y, double origin_x,double origin_y,double scale_x,double scale_y,double rot_ang){ double tempx, tempy; for_x *= scale_x; for_y *= scale_y; tempx = for_x; tempy = for_y; for_x = tempx * cos(rot_ang) + tempy * sin(rot_ang); for_y = tempy * cos(rot_ang) - tempx * sin(rot_ang); for_x += origin_x; for_y += origin_y; putpixel(for_x,for_y,RGB(255,255,255)); } void DrawTotalXY(Parsers P, double Origin_X,double Origin_Y,double Scale_X,double Scale_Y,double Rot_ang, double Start, double End, double Step, struct ExprNode* For_X, struct ExprNode* For_Y) { double x,y; P.Parameter = Start; if (Step \u0026gt; 0) { while (P.Parameter \u0026lt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); P.Parameter += Step; } } else if(Step \u0026lt; 0){ while (P.Parameter \u0026gt;= End) { x = P.GetExpValue(For_X) ; y = P.GetExpValue(For_Y) ; DrawXY(x,y,Origin_X,Origin_Y,Scale_X,Scale_Y,Rot_ang); P.Parameter += Step; } } } int main() { Parsers P; P.Parser(); initgraph(1000, 700); for(int i = 0; i \u0026lt; Start.size(); i ++) DrawTotalXY(P,Origin_X[i],Origin_Y[i],Scale_X[i],Scale_Y[i],Rot_ang[i],Start[i],End[i],Step[i],For_X[i],For_Y[i]); _getch(); closegraph(); return 0; } ","date":"2022/11/21","externalUrl":null,"permalink":"/blogs/fglcompiler3/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 绘图器","title":"编译原理上机(3) - 绘图器","type":"blogs"},{"content":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 语法分析器\n报告及代码链接：\nZhanYirui/FGLCompiler C\u0026#43;\u0026#43; 1 0 第二部分:语法分析器(完整代码在结尾)\n测试文本:\norigin is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 语法分析器的目的是判断词法分析器得到的记号是否合法，以及记号组成的句子是否合法。\n语法分析器的设计思路:\n​ 比如文本里装的是:\n​ ORIGIN IS (-16+5**3/cos(pi),2*120);\n​ 我们通过第一部分的词法分析器就能得到一个记号流:\n​ ORIGIN IS L_BRACKET CONST_ID MUL CONST_ID COMMA CONST_ID MUL CONST_ID R_BRACKET SEMICO\n​ 我们现在从记号流里面取出第一个记号ORIGIN，所以我们要匹配OriginStatement，继续取下一个记号，要想符合OriginStatement的语法，下一个记号应该匹配IS，如果下一个记号不能匹配IS，那就语法报错后退出；如果下一个记号匹配的是IS，我们就继续匹配，如果我们在匹配过程中取到了ERRTOKEN类型的记号，那么就词法报错后退出。\n​ 所以设计思路就是:\n​ 依次取记号，如果是ERRTOKEN类型就词法报错，如果匹配不了语法，那就语法报错。\n​ 需要注意到的是括号和逗号之间的是两个表达式，所以我们要设计一个表达式树结构，比如给的这个例子我们匹配完左括号之后，要生成一个表达式树来表示-16+5**3/cos(pi)。\n表达式树的节点可以分为三类:\n​ 1.叶节点: 常数CONST_ID、参数T\n​ 2.有两个孩子的节点 也就是运算符节点: 加PLUS、减MINUS、乘MUL、除DIV、幂运算POWER (这时候有两个特例就是一元加和一元减，比如+5，这个+的左孩子就是NULL，右孩子是5，就将+5转换成5了；还有-5，这个-的左孩子就是0，右孩子就是5，就将-5转换成0-5了)\n​ 3.有一个孩子的节点 也就是函数节点: 函数FUNC\n表达式树节点代码:\ntypedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; 表达式树节点的生成，本来我是根据匹配的记号类型的不同设计四个函数生成不同类型的节点，但是PPT上给出的利用可变列表生成节点的方法更简便，代码如下。 这段代码的意思是: 如果现在匹配的是常数CONST_ID类型，那我们传进去的肯定是常数的值value，我们就可以生成一个节点，这个节点的CaseConst指针指向常数的值；如果我们匹配的是参数T类型，那就生成一个节点，这个节点的CaseParmPtr指针指向Parameter；如果我们匹配的是函数FUNC类型，那我们传进去的肯定是一个函数指针以及一个表达式树节点，那就可以生成一个节点，这个节点的MathFuncPtr指针指向传入的函数，Child孩子指针指向传入的表达式树节点；如果我们匹配的是运算符例如PLUS/MINUS这些类型，那我们传进去的肯定是两个表达式节点，那就可以生成一个节点，这个节点的Left左孩子指针指向传入的第一个节点，Right右孩子指针指向传入的第二个节点。\nstruct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } 利用递归进行表达式树的打印，注意一下，上面两段代码都是表达式树的节点的设计和生成，下面的代码是打印一整棵表达式树。通过递归先序遍历打印表达式树：传入表达式树的根节点，如果节点类型是CONST_ID那就说明这个节点只有CaseConst指针有值，打印CaseConst指针指向的值；如果节点类型是T那就打印\u0026quot;T\u0026quot;；如果节点类型是FUNC那就说明这个节点的MathFuncPtr和Child指针有值，先根据MathFuncPtr指向的函数打印函数的名称，然后用递归打印以孩子节点作为根节点的子树；如果节点类型是运算符，那就先打印运算符，然后递归打印分别以左右孩子节点为根节点的两棵子树。\nvoid OutExprNode(struct ExprNode* Tree){ cout \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34;; switch (Tree-\u0026gt;OpCode) { case CONST_ID: cout \u0026lt;\u0026lt; Tree-\u0026gt;Content.CaseConst \u0026lt;\u0026lt; endl;break; case T: cout \u0026lt;\u0026lt; \u0026#34;T\u0026#34; \u0026lt;\u0026lt; endl;break; case FUNC:{ if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sin){cout \u0026lt;\u0026lt; \u0026#34;sin\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = cos){cout \u0026lt;\u0026lt; \u0026#34;cos\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = log){cout \u0026lt;\u0026lt; \u0026#34;log\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = exp){cout \u0026lt;\u0026lt; \u0026#34;exp\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = tan){cout \u0026lt;\u0026lt; \u0026#34;tan\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sqrt){cout \u0026lt;\u0026lt; \u0026#34;sqrt\u0026#34; \u0026lt;\u0026lt; endl;} OutExprNode(Tree-\u0026gt;Content.CaseFunc.Child); }break; case PLUS:{ cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MINUS:{ cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MUL:{ cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case DIV:{ cout \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case POWER:{ cout \u0026lt;\u0026lt; \u0026#34;**\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; } } 绘图语言的文法:\nProgram -\u0026gt; { Statement SEMICO }\nStatement -\u0026gt; OriginStatement | ScaleStatement | RotStatement | ForStatement\nOriginStatement -\u0026gt; ORIGIN IS L_BRACKET Expression COMMA Expression R_BRACKET\nScaleStatement -\u0026gt; SCALE IS L_BRACKET Expression COMMA Expression R_BRACKET\nRotStatement -\u0026gt; ROT IS Expression\nForStatement -\u0026gt; FOR T FROM Expression TO Expression STEP Expression DRAW L_BRACKET Expression COMMA Expression R_BRACKET\n表达式树的产生式:\nExpression -\u0026gt; Term { ( PLUS | MINUS ) Term }\nTerm -\u0026gt; Factor { ( MUL | DIV ) Factor }\nFactor -\u0026gt; PLUS Factor | MINUS Factor | Component\nComponent -\u0026gt; Atom POWER Component | Atom\nAtom -\u0026gt; CONST_ID | T | FUNC L_BRACKET Expression R_BRACKET | L_BRACKET Expression R_BRACKET\n根据绘图语言文法和表达式树的产生式，我们可以设计一个Parsers类，在类里利用迭代实现文法和表达式树的产生。\nParsers类里我们首先定义一个构造函数 Parsers(){LoadFileTokens();} 作用是当我们创建一个Parsers类实例的时候自动调用LoadFileTokens()函数将文本的记号流装到容器里。\n先写三个辅助函数\nvoid FetchToken();\nvoid MatchToken(Token_Type t);\nvoid SyntaxError(int x);\nvoid FetchToken(); 这个函数的作用是从记号流里获取一个记号，如果获取的记号是ERRTOKEN类，就词法报错后退出\nvoid FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t); 这个函数的参数是一个单词类型，作用是将当前从记号流里获取的记号和这个单词类型进行匹配，如果不匹配就语法报错后退出，否则就获取下一个记号\nvoid MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x); 这个函数的参数是一个整数，如果整数是1就代表词法错误，如果整数是2就代表语法错误\nvoid SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No: \u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; 有一个错误记号: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No: \u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; 有一个不是预期的记号: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } 根据上面给出的文法和表达式树的产生式，我们利用迭代实现文法和表达式树的生成，我们需要下列函数\nvoid Parser();\nvoid Program();\nvoid Statement();\nvoid OriginStatement();\nvoid ScaleStatement();\nvoid ForStatement();\nvoid RotStatement();\nstruct ExprNode* Expression();\nstruct ExprNode* Term();\nstruct ExprNode* Factor();\nstruct ExprNode* Component();\nstruct ExprNode* Atom();\nParser()函数获取第一个记号，然后进入Program()函数\nvoid Parser(){ FetchToken(); Program(); } 根据上述文法 Program -\u0026gt; { Statement SEMICO }\n我们写一个 Program()函数，如下:\nvoid Program(){ while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); } } 根据上述文法 Statement -\u0026gt; OriginStatement | ScaleStatement | RotStatement | ForStatement\n我们写一个Statement()函数，如下:\nvoid Statement(){ if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); } 根据上述文法 OriginStatement -\u0026gt; ORIGIN IS L_BRACKET Expression COMMA Expression R_BRACKET\n我们写一个OriginStatement()函数，如下：// ScaleStatement()、RotStatement()、ForStatement()这三个函数根据上述文法可以类比OriginStatement()函数写一下\nvoid OriginStatement(){ MatchToken(ORIGIN); MatchToken(IS); MatchToken(L_BRACKET); origin_xptr = Expression(); MatchToken(COMMA); origin_yptr = Expression(); MatchToken(R_BRACKET); } 根据上面表达式树的产生式第一条\nExpression -\u0026gt; Term { ( PLUS | MINUS ) Term }\n写一个struct ExprNode* Expression()函数，如下:\nstruct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } 其他表达式树生成函数跟Expression()函数类似，根据上面表达式树的产生式可以类比Expression()函数依次写出来，不想分析了，放在底下完整代码里了，第二部分语法分析器结束。\n语法分析器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdarg\u0026gt; #include \u0026lt;graphics.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } typedef double (*FuncPtr)(double); struct ExprNode{ Token_Type OpCode; union{ struct{ ExprNode *Left, *Right; } CaseOperator; struct{ ExprNode *Child; FuncPtr MathFuncPtr; }CaseFunc; double CaseConst; double *CaseParmPtr; }Content; }; class Parsers{ public: Parsers(){LoadFileTokens();} double Parameter = 0; struct ExprNode *origin_xptr, *origin_yptr, *scale_xptr, *scale_yptr, *rot_ptr, *start_ptr, *end_ptr, *step_ptr, *for_xptr, *for_yptr; static int cnt; Tokens TempToken; struct ExprNode* MakeExprNode(Token_Type opcode,...){ struct ExprNode *ExprPtr = new (struct ExprNode); ExprPtr -\u0026gt; OpCode = opcode; va_list ArgPtr; va_start(ArgPtr,opcode); switch (opcode) { case CONST_ID:ExprPtr-\u0026gt;Content.CaseConst =(double) va_arg(ArgPtr,double );break; case T:ExprPtr-\u0026gt;Content.CaseParmPtr = \u0026amp;Parameter;break; case FUNC: ExprPtr-\u0026gt;Content.CaseFunc.MathFuncPtr = (FuncPtr) va_arg(ArgPtr,FuncPtr); ExprPtr-\u0026gt;Content.CaseFunc.Child = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; default: ExprPtr-\u0026gt;Content.CaseOperator.Left = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*); ExprPtr-\u0026gt;Content.CaseOperator.Right = (struct ExprNode*) va_arg(ArgPtr,struct ExprNode*);break; } va_end(ArgPtr); return ExprPtr; } void OutExprNode(struct ExprNode* Tree){ cout \u0026lt;\u0026lt; \u0026#34;\\t\\t\u0026#34;; switch (Tree-\u0026gt;OpCode) { case CONST_ID: cout \u0026lt;\u0026lt; Tree-\u0026gt;Content.CaseConst \u0026lt;\u0026lt; endl;break; case T: cout \u0026lt;\u0026lt; \u0026#34;T\u0026#34; \u0026lt;\u0026lt; endl;break; case FUNC:{ if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sin){cout \u0026lt;\u0026lt; \u0026#34;sin\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = cos){cout \u0026lt;\u0026lt; \u0026#34;cos\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = log){cout \u0026lt;\u0026lt; \u0026#34;log\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = exp){cout \u0026lt;\u0026lt; \u0026#34;exp\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = tan){cout \u0026lt;\u0026lt; \u0026#34;tan\u0026#34; \u0026lt;\u0026lt; endl;} else if(Tree-\u0026gt;Content.CaseFunc.MathFuncPtr = sqrt){cout \u0026lt;\u0026lt; \u0026#34;sqrt\u0026#34; \u0026lt;\u0026lt; endl;} OutExprNode(Tree-\u0026gt;Content.CaseFunc.Child); }break; case PLUS:{ cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MINUS:{ cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case MUL:{ cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case DIV:{ cout \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; case POWER:{ cout \u0026lt;\u0026lt; \u0026#34;**\u0026#34; \u0026lt;\u0026lt; endl; OutExprNode(Tree-\u0026gt;Content.CaseOperator.Left); OutExprNode(Tree-\u0026gt;Content.CaseOperator.Right); }break; } } void FetchToken(){ TempToken = TokenStream[cnt]; cnt ++; if(TempToken.type == ERRTOKEN) SyntaxError(1); } void MatchToken(Token_Type t){ if(TempToken.type != t) SyntaxError(2); FetchToken(); } void SyntaxError(int x){ if(x == 1){ cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Error Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } else if(x == 2) { cout \u0026lt;\u0026lt; \u0026#34;line No:\u0026#34; \u0026lt;\u0026lt; TempToken.TokenLine \u0026lt;\u0026lt; \u0026#34; Has An Unexpected Token: \u0026#34; \u0026lt;\u0026lt; TempToken.lexeme \u0026lt;\u0026lt; endl; exit(0); } } void Parser(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Parser\u0026#34; \u0026lt;\u0026lt; endl; FetchToken(); Program(); cout \u0026lt;\u0026lt; \u0026#34;exit from Parser\u0026#34; \u0026lt;\u0026lt; endl; } void Program(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Program\u0026#34; \u0026lt;\u0026lt; endl; while (TempToken.type != NONTOKEN){ Statement(); MatchToken(SEMICO); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ;\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;exit from Program\u0026#34; \u0026lt;\u0026lt; endl; } void Statement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in Statement\u0026#34; \u0026lt;\u0026lt; endl; if(TempToken.type == ORIGIN) OriginStatement(); else if(TempToken.type == SCALE) ScaleStatement(); else if(TempToken.type == ROT) RotStatement(); else if(TempToken.type == FOR) ForStatement(); else SyntaxError(2); cout \u0026lt;\u0026lt; \u0026#34;exit from Statement\u0026#34; \u0026lt;\u0026lt; endl; } void OriginStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in OriginStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(ORIGIN); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ORIGIN\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; origin_xptr = Expression(); OutExprNode(origin_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; origin_yptr = Expression(); OutExprNode(origin_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from OriginStatement\u0026#34; \u0026lt;\u0026lt; endl; } void RotStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in RotStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(ROT); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ROT\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; rot_ptr = Expression(); OutExprNode(rot_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from RotStatement\u0026#34; \u0026lt;\u0026lt; endl; } void ScaleStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in ScaleStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(SCALE); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken SCALE\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(IS); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken IS\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; scale_xptr = Expression(); OutExprNode(scale_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; scale_yptr = Expression(); OutExprNode(scale_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from ScaleStatement\u0026#34; \u0026lt;\u0026lt; endl; } void ForStatement(){ cout \u0026lt;\u0026lt; \u0026#34;enter in ForStatement\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(FOR); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken FOR\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(T); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken T\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(FROM); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken FROM\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; start_ptr = Expression(); OutExprNode(start_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(TO); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken TO\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; end_ptr = Expression(); OutExprNode(end_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(STEP); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken STEP\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; step_ptr = Expression(); OutExprNode(step_ptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(DRAW); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken DRAW\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(L_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken (\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; for_xptr = Expression(); OutExprNode(for_xptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(COMMA); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken ,\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;enter in Expression\u0026#34; \u0026lt;\u0026lt; endl; for_yptr = Expression(); OutExprNode(for_yptr); cout \u0026lt;\u0026lt; \u0026#34;exit from Expression\u0026#34; \u0026lt;\u0026lt; endl; MatchToken(R_BRACKET); cout \u0026lt;\u0026lt; \u0026#34;\\tmatchtoken )\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;exit from ForStatement\u0026#34; \u0026lt;\u0026lt; endl; } struct ExprNode* Expression(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Term(); while (TempToken.type == PLUS || TempToken.type == MINUS) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Term(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Term(){ struct ExprNode *left, *right; Token_Type token_tmp; left = Factor(); while (TempToken.type == MUL || TempToken.type == DIV) { token_tmp = TempToken.type; MatchToken(token_tmp); right = Factor(); left = MakeExprNode(token_tmp,left,right); } return left; } struct ExprNode* Factor(){ struct ExprNode *left, *right; if(TempToken.type == PLUS){ MatchToken(PLUS); right = Factor(); left = NULL; right = MakeExprNode(PLUS,left,right); } else if(TempToken.type == MINUS){ MatchToken(MINUS); right = Factor(); left = MakeExprNode(CONST_ID,0.0); right = MakeExprNode(MINUS,left,right); } else right = Component(); return right; } struct ExprNode* Component(){ struct ExprNode *left, *right; left = Atom(); if(TempToken.type == POWER){ MatchToken(POWER); right = Component(); left = MakeExprNode(POWER,left,right); } return left; } struct ExprNode* Atom(){ struct ExprNode *address, *tmp; double const_value; FuncPtr funcPtr_value; if(TempToken.type == CONST_ID){ const_value = TempToken.value; MatchToken(CONST_ID); address = MakeExprNode(CONST_ID,const_value); } else if(TempToken.type == T){ MatchToken(T); address = MakeExprNode(T); } else if(TempToken.type == FUNC){ funcPtr_value = TempToken.FuncPtr; MatchToken(FUNC); MatchToken(L_BRACKET); tmp = Expression(); address = MakeExprNode(FUNC,funcPtr_value,tmp); MatchToken(R_BRACKET); } else if(TempToken.type == L_BRACKET){ MatchToken(L_BRACKET); address = Expression(); MatchToken(R_BRACKET); } else SyntaxError(2); return address; } }; int Parsers::cnt = 0; int main() { Parsers P; P.Parser(); return 0; } ","date":"2022/11/20","externalUrl":null,"permalink":"/blogs/fglcompiler2/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 语法分析器","title":"编译原理上机(2) — 语法分析器","type":"blogs"},{"content":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 词法分析器\n报告及代码链接：\nZhanYirui/FGLCompiler C\u0026#43;\u0026#43; 1 0 写在前头:\n下面给出的代码是我第一版写出来的，勉强能符合要求。我后来进行了代码的优化和功能的添加，希望各位能够借鉴我的思路自己写一遍。\n上机目的:\n例如: ORIGIN IS (360,240); \u0026ndash; 将原点平移到(360,240)位置\n​ SCALE IS (100,100); // 将横坐标和纵坐标都放大100倍\n​ SCALE IS (100,100/3); \u0026ndash; 横坐标放大100倍，纵坐标放大100/3倍\n​ ROT IS PI/2; // 图形逆时针旋转90度\n​ FOR T FROM 0 TO 2PI STEP PI/50 DRAW(cos(T),sin(T)); //画圆\n​ 这是给定的一个绘图语言，有四种语句。ORIGIN语句，作用是将原点平移；SCALE语句，作用是将横纵坐标放大；ROT语句，作用是将图形旋转；FOR语句，作用是画图；还有\u0026ndash;和//，作用是注释。\n所以上机分三个部分:\n​ (1) 词法分析器:目的是将这些语句中的单词一个个识别出来\n​ (2) 语法分析器:目的是判断词法分析器得到的单词是否有错误，以及识别到的单词组成的语句符不符合规定\n​ (3) 绘图器:通过识别到的语句进行画图\n第一部分:词法分析器 (完整代码在结尾)\n测试文本:\norigin is (350,400); scale is (10,10); rot is pi; for t from 0 to 2*pi step pi/10000 draw(16*sin(t)*sin(t)*sin(t),13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)); --桃心线 origin is (200,200); scale is (100,100); for t from 0 to 2*pi step pi/10000 draw(cos(t)*cos(t)*cos(t),sin(t)*sin(t)*sin(t)); --星型线 ​ 词法分析器的目的说白了就是将文件中的单词一个个提取出来并分类\n比如:ORIGIN IS (360,240); 将这个句子中的单词提取出来就是ORIGIN、IS、(、360、,、240、)、; 我们将提取到的单词进行分类，比如360和240就是同一类都是常数，于是我们可以将单词的种类分为:\n​ 保留字: ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,T\n​ 分隔符: SEMICO(;),L_BRACKET((),R_BRACKET()),COMMA(,)\n​ 运算符: PLUS(+),MINUS(-),MUL(*),DIV(/),POWER(**)\n​ 参数: T\n​ 函数: FUNC\n​ 常数: CONST_ID\n​ 结尾记号: NONTOKEN\n​ 出错记号: ERRTOKEN\n我们利用一个枚举enum类型来将单词的种类给装起来:\nenum Token_Type { ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //结尾记号 ERRTOKEN //出错记号 }; 单词有自己的属性，上面我们用enum装起来的只是单词的一个单词种类属性，单词还有文本属性，常数还有自己的值属性，函数还有自己的函数指针属性，还有每个单词在文件中的行数属性。比如Origin这个单词，它的单词种类是ORIGIN，文本是Origin，它不是常数所以值属性规定为0，也不是函数所以函数指针设为NULL；再比如360这个单词，它的单词种类是CONST_ID，文本是360，它是常数所以值属性为360，它不是函数所以函数指针设为NULL;再比如sin这个单词，它的单词种类是FUNC，文本是sin，它不是常数所以值属性为0，它是函数所以函数指针设为sin。\n所以我们用struct定义一个单词结构体:\ntypedef struct Tokens { Token_Type type; //单词种类 string lexeme; //单词的文本 double value; // 常数单词的值 double (*FuncPtr)(double); // 函数单词的函数指针 int TokenLine; // 单词在文件中的行数 } Tokens; 这时候我们意识到一个问题，当我们在文件里识别到Origin、Scale、sin、Pi这些字符串单词的时候我们要给它归类到保留字、函数、常数等我们预先定义的单词类型，但当我们识别到abcd、xyz这些字符串单词的时候，我们要给这些单词归类到ERRTOKEN类型。所以我们需要一个单词字典，当我们识别到字符串单词的时候，要先查找这个单词字典，如果在字典里没有找到，我们就要将它们归类到ERRTOKEN类型。\n所以我们定义一个单词字典:\nstatic Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; 利用C++的类，我们定义一个Scanner类。\n这个类里有三个成员变量:\n​ string FileName;\n​ string TokenBuffer;\n​ fstream F;\n其中TokenBuffer是字符串缓冲区，因为我们读文件是利用循环一个字符一个字符地读，所以我们要有一个字符串缓冲区来将字符一个个装起来。比如文件里有个Origin单词，我们读文件时，先读到一个O字母，我们把O装到缓冲区，然后再读r字母，再装到缓冲区，以此类推，到最后读完这个单词的时候，缓冲区就装了Origin这个单词的文本值了。\n类里还有七个成员函数:\n​ void OpenFile();\n​ void CloseFile();\n​ void EmptyBuffer();\n​ void AddCharToBuffer(char TempC);\n​ Tokens SearchCharInDict(string TempS);\n​ Tokens CreateTokens(Token_Type type,string lexeme,double value,double (*FuncPtr)(double),int Line);\n​ Tokens GetToken();\n接下来我依次来说明这些成员函数的作用:\nvoid OpenFile(); 这个函数作用很简单，就是输入文件名后打开文件。\nvoid OpenFile(){ // 输入文件名打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(); 这个函数就是关闭文件。\nvoid CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(); 这个函数的作用是清空缓冲区，读上一个单词的时候上一个单词的文本值还在缓冲区里面，我们读下一个单词的时候就要先清空缓冲区。\nvoid EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC); 这个函数的作用就是将一个字符装到缓冲区里面。\nvoid AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS); 这个函数的作用是查单词字典，上面我们说过了，当我们读字符串单词的时候，要先在单词字典里面进行查找，如果没找到的话要将其归类为ERRORTOKEN类型。任务规定语言对大小写不敏感，所以Origin,origin,ORIGIN都要识别为ORIGIN类型，所以我们将存在缓冲区的单词文本值传进去的时候，将其全部转换为大写字母，我这里是利用C++自带的算法库进行大写转换的。\nTokens SearchCharInDict(string TempS){ //查单词字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; //利用C++算法库进行大写转换 transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme) { T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateTokens(Token_Type type,string lexeme,double value,double (*FuncPtr)(double),int Line); 这个函数作用是传入单词的各个属性，返回一个单词，因为底下GetToken()函数在生成单词时有很多重复代码，所以就专门写了个函数进行单词生成。\nTokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ // 生成单词 Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(); 这个函数是Scanner类最核心的成员函数，作用是获取文件中的一个单词。\n设计思路:我们读文件是一个字符一个字符地读。所以我们根据读到的字符进行不同的设计。\n​ 当我们读到的字符是文件结尾字符 \u0026lsquo;EOF\u0026rsquo; 的时候，我们返回一个类型为NONTOKEN的单词。\n​ 当我们读到的字符是空格 \u0026rsquo; \u0026rsquo; 或者制表符 \u0026lsquo;\\t\u0026rsquo; 的时候，不作处理，继续读下一个字符。\n​ 当我们读到的字符是换行符 \u0026lsquo;\\n\u0026rsquo; 的时候，我们将行数加1，然后继续读下一个字符。\n​ 当我们读到的字符是字母 \u0026lsquo;[a-zA-Z]\u0026rsquo; 的时候，我们将字符装到缓冲区，然后读下一个字符，如果下一个字符还是字母，那就继续装到缓冲区，直到读的字符不是字母为止，这个时候缓冲区里面装的就是单词的文本值了。然后查单词字典，是预设的单词的话就返回一个预设的单词，不然就返回一个类型为ERRTOKEN的单词。\n​ 当我们读到的字符是数字 \u0026lsquo;[0-9]\u0026rsquo; 的时候，我们将字符装到缓冲区，然后读下一个字符，如果下一个字符还是数字，就继续装到缓冲区，直到读的字符不是数字为止。由于数字还能有小数，所以这时候如果读的字符是小数点 \u0026lsquo;.\u0026rsquo; ，那就继续装到缓冲区，然后读下一个字符，如果是数字就装到缓冲区，直到读的字符不是数字为止，这个时候缓冲区里面就是常数的文本值。最后返回一个类型为CONST_ID，值属性为利用stod()函数转换缓冲区里的文本值为常数值 的单词。\n​ 当我们读到的字符是分号 \u0026lsquo;;\u0026rsquo; 的时候，返回一个类型为SEMICO的单词。\n​ 当我们读到的字符是左括号 \u0026lsquo;(\u0026rsquo; 的时候，返回一个类型为L_BRACKET单词。\n​ 当我们读到的字符是分号右括号 \u0026lsquo;)\u0026rsquo; 的时候，返回一个类型为R_BRACKET的单词。\n​ 当我们读到的字符是逗号 \u0026lsquo;,\u0026rsquo; 的时候，返回一个类型为COMMA的单词。\n​ 当我们读到的字符是加号 \u0026lsquo;+\u0026rsquo; 的时候，返回一个类型为PLUS的单词。\n​ 当我们读到的字符是减号 \u0026lsquo;-\u0026rsquo; 的时候，由于 \u0026ndash; 是注释，我们需要继续读下一个字符，如果下一个字符不是 \u0026lsquo;-\u0026rsquo;，那么我们返回一个类型为MINUS的单词，如果下一个字符是 \u0026lsquo;-\u0026rsquo;，我们就要继续往后读，直到读的字符是换行符 \u0026lsquo;\\n\u0026rsquo; 或者结束符 \u0026lsquo;EOF\u0026rsquo; 的时候结束，要是读的是 \u0026lsquo;\\n\u0026rsquo;就将行数加1然后继续下一个循环，要是读的是 \u0026lsquo;EOF\u0026rsquo; 就返回一个类型为NONTOKEN的单词。\n​ 当我们读到的字符是除号 \u0026lsquo;/\u0026rsquo; 的时候，跟读减号 \u0026lsquo;-\u0026rsquo; 的方法一样\n​ 当我们读到的字符是乘号 \u0026lsquo;*\u0026rsquo; 的时候，由于 * 是幂次运算，我们需要继续读下一个字符，如果下一个字符不是 \u0026lsquo;*\u0026rsquo;，那么我们返回一个类型为MUL的单词，如果下一个字符是 \u0026lsquo;*\u0026rsquo;，我们就返回一个类型为POWER的单词。*\nTokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;){ c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } Scanner类我们就已经设计好了，这个时候我选择用一个循环反复调用GetToken()函数将文件里面的所有单词存放到一个容器里面，后面设计语法分析器的时候就可以直接从容器里面取了，不过这也是看个人喜好，用一次调一次GetToken()函数也可以。\nvector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens() { Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } 再然后就是打印所有单词了，就不写了，直接放到完整代码里面，词法分析器部分就结束了。\n词法分析器完整代码 # #include \u0026lt;cmath\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iomanip\u0026gt; #define pi acos(-1.0) #define e exp(1.0) using namespace std; enum Token_Type{ ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,//保留字 T, //参数 SEMICO,L_BRACKET,R_BRACKET,COMMA, //; ( ) ,分隔符 PLUS,MINUS,MUL,DIV,POWER, //+ - * / **运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号 }; typedef struct Tokens{ Token_Type type; string lexeme; double value; double (*FuncPtr)(double); int TokenLine; } Tokens; static Tokens TokenTab[] = { {ORIGIN, \u0026#34;ORIGIN\u0026#34;, 0.0, NULL,0}, {SCALE, \u0026#34;SCALE\u0026#34;, 0.0, NULL,0}, {ROT, \u0026#34;ROT\u0026#34;, 0.0, NULL,0}, {IS, \u0026#34;IS\u0026#34;, 0.0, NULL,0}, {TO, \u0026#34;TO\u0026#34;, 0.0, NULL,0}, {STEP, \u0026#34;STEP\u0026#34;, 0.0, NULL,0}, {DRAW, \u0026#34;DRAW\u0026#34;, 0.0, NULL,0}, {FOR, \u0026#34;FOR\u0026#34;, 0.0, NULL,0}, {FROM, \u0026#34;FROM\u0026#34;, 0.0, NULL,0}, {T, \u0026#34;T\u0026#34;, 0.0, NULL,0}, {FUNC, \u0026#34;SIN\u0026#34;, 0.0, sin,0}, {FUNC, \u0026#34;COS\u0026#34;, 0.0, cos,0}, {FUNC, \u0026#34;TAN\u0026#34;, 0.0, tan,0}, {FUNC, \u0026#34;LN\u0026#34;, 0.0, log,0}, {FUNC, \u0026#34;EXP\u0026#34;, 0.0, exp,0}, {FUNC, \u0026#34;SQRT\u0026#34;, 0.0, sqrt,0}, {CONST_ID, \u0026#34;PI\u0026#34;, pi, NULL,0}, {CONST_ID, \u0026#34;E\u0026#34;, e, NULL,0} }; class Scanner{ public: void OpenFile(){ //打开文件 cin \u0026gt;\u0026gt; FileName; F.open(FileName,ios::in|ios::out); } void CloseFile(){ //关闭文件 F.close(); } void EmptyBuffer(){ //清空缓冲区 TokenBuffer = \u0026#34;\u0026#34;; } void AddCharToBuffer(char TempC){ //将字符添加到缓冲区 TokenBuffer += TempC; } Tokens SearchCharInDict(string TempS){ //查字典 Tokens T = {ERRTOKEN, TempS, 0.0, NULL,0}; transform(TempS.begin(),TempS.end(),TempS.begin(),::toupper); for(int i = 0; i \u0026lt; 18; i ++) { if (TempS == TokenTab[i].lexeme){ T.type = TokenTab[i].type; T.value = TokenTab[i].value; T.FuncPtr = TokenTab[i].FuncPtr; } } return T; } Tokens CreateToken(Token_Type type, string lexeme, double value, double (*FuncPtr)(double), int Line){ Tokens TempToken; TempToken.type = type; TempToken.lexeme = lexeme; TempToken.value = value; TempToken.FuncPtr = FuncPtr; TempToken.TokenLine = Line; return TempToken; } Tokens GetToken(){ char c; static int line = 1; //行数 Tokens TempT; EmptyBuffer(); //清空缓冲区 while(1){ c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39;) continue; else if(c == \u0026#39;\\n\u0026#39;){ line++; continue;} else if(isalpha(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isalnum(c)) AddCharToBuffer(c); else break; } F.putback(c); TempT = SearchCharInDict(TokenBuffer); TempT.TokenLine = line; return TempT; } else if(isdigit(c)){ AddCharToBuffer(c); while(1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } if(c == \u0026#39;.\u0026#39;) { AddCharToBuffer(c); while (1){ c = F.get(); if(isdigit(c)) AddCharToBuffer(c); else break; } } F.putback(c); TempT = CreateToken(CONST_ID,TokenBuffer, stod(TokenBuffer),NULL,line); return TempT; } else if(c == \u0026#39;;\u0026#39;){ TempT = CreateToken(SEMICO,\u0026#34;;\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;(\u0026#39;){ TempT = CreateToken(L_BRACKET,\u0026#34;(\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;)\u0026#39;){ TempT = CreateToken(R_BRACKET,\u0026#34;)\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;,\u0026#39;){ TempT = CreateToken(COMMA,\u0026#34;,\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;+\u0026#39;){ TempT = CreateToken(PLUS,\u0026#34;+\u0026#34;,0.0,NULL,line); return TempT; } else if(c == \u0026#39;-\u0026#39;) { c = F.get(); if(c == \u0026#39;-\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(MINUS,\u0026#34;-\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;/\u0026#39;){ c = F.get(); if(c == \u0026#39;/\u0026#39;){ while(c!=\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;c!=EOF) c = F.get(); if(c == EOF){ TempT = CreateToken(NONTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } else { line++; continue; } } else { F.putback(c); TempT = CreateToken(DIV,\u0026#34;/\u0026#34;,0.0,NULL,line); return TempT; } } else if(c == \u0026#39;*\u0026#39;){ c = F.get(); if(c == \u0026#39;*\u0026#39;){ TempT = CreateToken(POWER,\u0026#34;**\u0026#34;,0.0,NULL,line); return TempT; } else{ F.putback(c); TempT = CreateToken(MUL,\u0026#34;*\u0026#34;,0.0,NULL,line); return TempT; } } else{ TempT = CreateToken(ERRTOKEN,\u0026#34;EOF\u0026#34;,0.0,NULL,line); return TempT; } } } private: string FileName, TokenBuffer = \u0026#34;\u0026#34;; //文件名和缓冲区 fstream F; }; vector\u0026lt;Tokens\u0026gt; TokenStream; void LoadFileTokens(){ Scanner s; Tokens t; cout \u0026lt;\u0026lt; \u0026#34;Please Enter A File With Path:\u0026#34; \u0026lt;\u0026lt; endl; s.OpenFile(); t = s.GetToken(); TokenStream.push_back(t); while (t.type != NONTOKEN){ t = s.GetToken(); TokenStream.push_back(t); } s.CloseFile(); } void Cout(string type, string lexeme, double value, string funcptr){ cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; type \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; lexeme \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(14) \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\t|\\t\u0026#34; \u0026lt;\u0026lt; setw(16) \u0026lt;\u0026lt; funcptr \u0026lt;\u0026lt; endl; } void COUT(Tokens t){ switch (t.type) { case ORIGIN:Cout(\u0026#34;ORIGIN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case SCALE:Cout(\u0026#34;SCALE\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case ROT:Cout(\u0026#34;ROT\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case IS:Cout(\u0026#34;IS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case TO:Cout(\u0026#34;TO\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case STEP:Cout(\u0026#34;STEP\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case DRAW:Cout(\u0026#34;DRAW\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FOR:Cout(\u0026#34;FOR\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FROM:Cout(\u0026#34;FROM\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case T:Cout(\u0026#34;T\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case SEMICO:Cout(\u0026#34;SEMICO\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case L_BRACKET:Cout(\u0026#34;L_BRACKET\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case R_BRACKET:Cout(\u0026#34;R_BRACKET\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case COMMA:Cout(\u0026#34;COMMA\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case PLUS:Cout(\u0026#34;PLUS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case MINUS:Cout(\u0026#34;MINUS\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case MUL:Cout(\u0026#34;MUL\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case DIV:Cout(\u0026#34;DIV\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case POWER:Cout(\u0026#34;POWER\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);break; case FUNC:{ string temp = t.lexeme; transform(temp.begin(),temp.end(),temp.begin(),::toupper); Cout(\u0026#34;FUNC\u0026#34;,t.lexeme,t.value,temp); };break; case CONST_ID:Cout(\u0026#34;CONST_ID\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; case NONTOKEN:Cout(\u0026#34;NONTOKEN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; case ERRTOKEN:Cout(\u0026#34;ERRTOKEN\u0026#34;,t.lexeme,t.value,\u0026#34;NULL\u0026#34;);;break; } } int main() { LoadFileTokens(); cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; \u0026#34;Token_Type\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; \u0026#34;String_Value\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(14) \u0026lt;\u0026lt; \u0026#34;Constant_Value\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t \\t\u0026#34; \u0026lt;\u0026lt; setw(16) \u0026lt;\u0026lt; \u0026#34;Function_Pointer\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-------------------------------------------------------------------------------------\u0026#34; \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; TokenStream.size(); i ++) COUT(TokenStream[i]); return 0; } ","date":"2022/11/19","externalUrl":null,"permalink":"/blogs/fglcompiler1/","section":"Blogs","summary":"西电编译原理大作业 - 函数绘图语言编译器 - C++实现 - 词法分析器","title":"编译原理上机(1) - 词法分析器","type":"blogs"},{"content":"","date":"0001/1/1","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001/1/1","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001/1/1","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]